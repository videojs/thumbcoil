/**
 * thumbcoil
 * @version 1.2.3
 * @copyright 2017 Brightcove, Inc.
 * @license Apache-2.0
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.thumbcoil = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var readCodebookValue = function readCodebookValue(codebook, expGolomb) {
  var bitString = expGolomb.bitReservoir;

  for (var i = 0; i < codebook.length; i++) {
    var o = codebook[i];
    var subString = bitString.slice(0, o.size);
    var index = o[subString];

    if (typeof index === 'number') {
      expGolomb.readBits(o.size);
      return index;
    }
  }
  return -999999;
  //expGolomb.bitStream = '';
};

exports.readCodebookValue = readCodebookValue;
var scaleFactorCB = [{
  "0": 60,
  "size": 1
}, {
  "100": 59,
  "size": 3
}, {
  "1010": 61,
  "1011": 58,
  "1100": 62,
  "size": 4
}, {
  "11010": 57,
  "11011": 63,
  "size": 5
}, {
  "111000": 56,
  "111001": 64,
  "111010": 55,
  "111011": 65,
  "size": 6
}, {
  "1111000": 66,
  "1111001": 54,
  "1111010": 67,
  "size": 7
}, {
  "11110110": 53,
  "11110111": 68,
  "11111000": 52,
  "11111001": 69,
  "11111010": 51,
  "size": 8
}, {
  "111110110": 70,
  "111110111": 50,
  "111111000": 49,
  "111111001": 71,
  "size": 9
}, {
  "1111110100": 72,
  "1111110101": 48,
  "1111110110": 73,
  "1111110111": 47,
  "1111111000": 74,
  "1111111001": 46,
  "size": 10
}, {
  "size": 11,
  "11111110101": 75,
  "11111110100": 76,
  "11111111001": 43,
  "11111111000": 45,
  "11111110110": 77,
  "11111110111": 78
}, {
  "size": 12,
  "111111110100": 44,
  "111111110111": 41,
  "111111110110": 42,
  "111111111001": 40,
  "111111110101": 79,
  "111111111000": 80
}, {
  "size": 13,
  "1111111110100": 81,
  "1111111110110": 82,
  "1111111110111": 38,
  "1111111110101": 39,
  "1111111111000": 83
}, {
  "size": 14,
  "11111111110010": 37,
  "11111111110111": 34,
  "11111111110110": 36,
  "11111111110101": 33,
  "11111111111001": 32,
  "11111111111000": 84,
  "11111111110100": 85,
  "11111111110011": 35
}, {
  "size": 15,
  "111111111110110": 30,
  "111111111110100": 87,
  "111111111110111": 31,
  "111111111110101": 89
}, {
  "size": 16,
  "1111111111110011": 27,
  "1111111111110100": 28,
  "1111111111110001": 29,
  "1111111111110010": 26,
  "1111111111110101": 24,
  "1111111111110110": 88,
  "1111111111110000": 86
}, {
  "size": 17,
  "11111111111110000": 23,
  "11111111111101110": 25,
  "11111111111101111": 22
}, {
  "size": 18,
  "111111111111100111": 2,
  "111111111111100100": 19,
  "111111111111100101": 3,
  "111111111111100011": 21,
  "111111111111100010": 90,
  "111111111111101000": 0,
  "111111111111100110": 1
}, {
  "size": 19,
  "1111111111111010010": 98,
  "1111111111111111010": 20,
  "1111111111111111011": 17,
  "1111111111111111000": 16,
  "1111111111111110111": 15,
  "1111111111111111110": 14,
  "1111111111111111111": 13,
  "1111111111111111101": 12,
  "1111111111111111100": 11,
  "1111111111111110000": 10,
  "1111111111111101111": 9,
  "1111111111111101110": 8,
  "1111111111111110110": 7,
  "1111111111111101101": 6,
  "1111111111111110001": 5,
  "1111111111111110101": 4,
  "1111111111111011001": 91,
  "1111111111111011010": 92,
  "1111111111111011011": 93,
  "1111111111111011100": 94,
  "1111111111111011101": 95,
  "1111111111111011110": 96,
  "1111111111111011000": 97,
  "1111111111111111001": 18,
  "1111111111111010011": 99,
  "1111111111111010100": 100,
  "1111111111111010101": 101,
  "1111111111111010110": 102,
  "1111111111111110010": 103,
  "1111111111111011111": 104,
  "1111111111111100111": 105,
  "1111111111111101000": 106,
  "1111111111111101001": 107,
  "1111111111111101010": 108,
  "1111111111111101011": 109,
  "1111111111111100110": 110,
  "1111111111111100000": 111,
  "1111111111111100001": 112,
  "1111111111111100010": 113,
  "1111111111111100011": 114,
  "1111111111111100100": 115,
  "1111111111111100101": 116,
  "1111111111111010111": 117,
  "1111111111111101100": 118,
  "1111111111111110100": 119,
  "1111111111111110011": 120
}];

exports.scaleFactorCB = scaleFactorCB;
var spectrumCB = [[], [{
  "0": 40,
  "size": 1
}, {
  "10000": 67,
  "10001": 13,
  "10010": 39,
  "10011": 49,
  "10100": 41,
  "10101": 37,
  "10110": 43,
  "10111": 31,
  "size": 5
}, {
  "1100000": 58,
  "1100001": 22,
  "1100010": 38,
  "1100011": 46,
  "1100100": 34,
  "1100101": 42,
  "1100110": 76,
  "1100111": 36,
  "1101000": 4,
  "1101001": 28,
  "1101010": 64,
  "1101011": 48,
  "1101100": 16,
  "1101101": 44,
  "1101110": 70,
  "1101111": 32,
  "1110000": 52,
  "1110001": 50,
  "1110010": 10,
  "1110011": 68,
  "1110100": 12,
  "1110101": 66,
  "1110110": 14,
  "1110111": 30,
  "size": 7
}, {
  "111100000": 73,
  "111100001": 19,
  "111100010": 61,
  "111100011": 51,
  "111100100": 47,
  "111100101": 35,
  "111100110": 33,
  "111100111": 55,
  "111101000": 65,
  "111101001": 45,
  "111101010": 25,
  "111101011": 15,
  "111101100": 7,
  "111101101": 29,
  "111101110": 59,
  "111101111": 57,
  "111110000": 21,
  "111110001": 1,
  "111110010": 27,
  "111110011": 53,
  "111110100": 69,
  "111110101": 77,
  "111110110": 23,
  "111110111": 79,
  "size": 9
}, {
  "1111110000": 5,
  "1111110001": 9,
  "1111110010": 75,
  "1111110011": 63,
  "1111110100": 11,
  "1111110101": 3,
  "1111110110": 17,
  "1111110111": 71,
  "size": 10
}, {
  "size": 11,
  "11111111101": 2,
  "11111111110": 54,
  "11111110101": 8,
  "11111110011": 56,
  "11111111000": 0,
  "11111110010": 24,
  "11111111100": 18,
  "11111110110": 72,
  "11111110000": 60,
  "11111111001": 74,
  "11111111011": 26,
  "11111111010": 62,
  "11111110111": 6,
  "11111111111": 78,
  "11111110001": 20,
  "11111110100": 80
}], [{
  "size": 3,
  "000": 40
}, {
  "size": 4,
  "0010": 67
}, {
  "size": 5,
  "00110": 13,
  "01010": 31,
  "01000": 37,
  "01001": 39,
  "00111": 41,
  "01011": 43,
  "01100": 49
}, {
  "100000": 12,
  "100001": 58,
  "100010": 64,
  "100011": 4,
  "100100": 36,
  "100101": 70,
  "100110": 68,
  "100111": 32,
  "101000": 16,
  "101001": 50,
  "101010": 28,
  "101011": 14,
  "101100": 30,
  "101101": 10,
  "101110": 76,
  "101111": 52,
  "110000": 44,
  "110001": 66,
  "size": 6,
  "011011": 22,
  "011010": 34,
  "011111": 38,
  "011101": 42,
  "011100": 46,
  "011110": 48
}, {
  "1100100": 47,
  "1100101": 65,
  "1100110": 19,
  "1100111": 33,
  "1101000": 61,
  "1101001": 75,
  "1101010": 71,
  "1101011": 25,
  "1101100": 29,
  "1101101": 79,
  "1101110": 15,
  "1101111": 1,
  "1110000": 11,
  "1110001": 55,
  "1110010": 73,
  "size": 7
}, {
  "11100110": 59,
  "11100111": 21,
  "11101000": 7,
  "11101001": 17,
  "11101010": 5,
  "11101011": 3,
  "11101100": 27,
  "11101101": 69,
  "11101110": 63,
  "11101111": 45,
  "11110000": 53,
  "11110001": 23,
  "11110010": 9,
  "11110011": 51,
  "11110100": 57,
  "11110101": 35,
  "11110110": 77,
  "11110111": 60,
  "11111000": 20,
  "size": 8
}, {
  "111110010": 56,
  "111110011": 0,
  "111110100": 24,
  "111110101": 26,
  "111110110": 80,
  "111110111": 6,
  "111111000": 62,
  "111111001": 18,
  "111111010": 8,
  "111111011": 72,
  "111111100": 54,
  "111111101": 2,
  "111111110": 74,
  "111111111": 78,
  "size": 9
}], [{
  "0": 0,
  "size": 1
}, {
  "1000": 27,
  "1001": 1,
  "1010": 9,
  "1011": 3,
  "size": 4
}, {
  "11000": 36,
  "11001": 4,
  "size": 5
}, {
  "110100": 12,
  "110101": 10,
  "110110": 30,
  "110111": 13,
  "111000": 28,
  "111001": 39,
  "size": 6
}, {
  "1110100": 40,
  "1110101": 31,
  "1110110": 37,
  "size": 7
}, {
  "11101110": 54,
  "11101111": 2,
  "11110000": 5,
  "11110001": 63,
  "11110010": 48,
  "size": 8
}, {
  "111100110": 7,
  "111100111": 16,
  "111101000": 45,
  "111101001": 14,
  "111101010": 66,
  "111101011": 6,
  "111101100": 21,
  "111101101": 15,
  "111101110": 18,
  "111101111": 11,
  "111110000": 57,
  "111110001": 49,
  "111110010": 22,
  "111110011": 42,
  "111110100": 43,
  "size": 9
}, {
  "1111101010": 46,
  "1111101011": 33,
  "1111101100": 34,
  "1111101101": 19,
  "1111101110": 67,
  "1111101111": 41,
  "1111110000": 64,
  "1111110001": 32,
  "1111110010": 8,
  "1111110011": 17,
  "1111110100": 75,
  "1111110101": 51,
  "1111110110": 29,
  "1111110111": 55,
  "1111111000": 25,
  "size": 10
}, {
  "size": 11,
  "11111111001": 23,
  "11111111000": 24,
  "11111110111": 76,
  "11111110011": 52,
  "11111110010": 72,
  "11111110100": 38,
  "11111110110": 44,
  "11111110101": 58
}, {
  "size": 12,
  "111111111100": 53,
  "111111110100": 35,
  "111111110101": 73,
  "111111111011": 50,
  "111111111010": 70,
  "111111110111": 78,
  "111111110110": 69,
  "111111111001": 79,
  "111111111000": 26
}, {
  "size": 13,
  "1111111111010": 20,
  "1111111111100": 47,
  "1111111111011": 60
}, {
  "size": 14,
  "11111111111011": 68,
  "11111111111010": 61,
  "11111111111100": 65
}, {
  "size": 15,
  "111111111111010": 80,
  "111111111111100": 71,
  "111111111111101": 59,
  "111111111111011": 77,
  "111111111111110": 56
}, {
  "size": 16,
  "1111111111111111": 62,
  "1111111111111110": 74
}], [{
  "1000": 4,
  "1001": 30,
  "size": 4,
  "0000": 40,
  "0111": 0,
  "0011": 39,
  "0010": 37,
  "0110": 36,
  "0100": 31,
  "0101": 27,
  "0001": 13
}, {
  "10100": 28,
  "10101": 12,
  "10110": 1,
  "10111": 10,
  "11000": 3,
  "11001": 9,
  "size": 5
}, {
  "1101000": 67,
  "1101001": 43,
  "1101010": 49,
  "1101011": 41,
  "1101100": 66,
  "1101101": 64,
  "1101110": 48,
  "1101111": 58,
  "1110000": 16,
  "size": 7
}, {
  "11100010": 14,
  "11100011": 42,
  "11100100": 22,
  "11100101": 32,
  "11100110": 46,
  "11100111": 38,
  "11101000": 34,
  "11101001": 63,
  "11101010": 57,
  "11101011": 45,
  "11101100": 55,
  "11101101": 11,
  "11101110": 21,
  "11101111": 5,
  "11110000": 15,
  "11110001": 19,
  "11110010": 29,
  "11110011": 7,
  "11110100": 33,
  "11110101": 54,
  "11110110": 2,
  "size": 8
}, {
  "111101110": 18,
  "111101111": 6,
  "111110000": 52,
  "111110001": 76,
  "111110010": 70,
  "111110011": 44,
  "111110100": 50,
  "111110101": 68,
  "size": 9
}, {
  "1111101100": 51,
  "1111101101": 75,
  "1111101110": 69,
  "1111101111": 25,
  "1111110000": 17,
  "1111110001": 73,
  "1111110010": 23,
  "1111110011": 61,
  "1111110100": 35,
  "1111110101": 79,
  "1111110110": 47,
  "1111110111": 59,
  "1111111000": 65,
  "1111111001": 53,
  "size": 10
}, {
  "size": 11,
  "11111111010": 20,
  "11111111100": 80,
  "11111111001": 60,
  "11111110100": 71,
  "11111110111": 72,
  "11111110110": 24,
  "11111111000": 8,
  "11111111011": 56,
  "11111111101": 26,
  "11111110101": 77,
  "11111111110": 78
}, {
  "size": 12,
  "111111111111": 62,
  "111111111110": 74
}], [{
  "0": 40,
  "size": 1
}, {
  "1000": 31,
  "1001": 49,
  "1010": 41,
  "1011": 39,
  "size": 4
}, {
  "11000": 48,
  "11001": 32,
  "11010": 30,
  "11011": 50,
  "size": 5
}, {
  "1110000": 22,
  "1110001": 42,
  "1110010": 58,
  "1110011": 38,
  "size": 7
}, {
  "11101000": 21,
  "11101001": 59,
  "11101010": 29,
  "11101011": 51,
  "11101100": 23,
  "11101101": 57,
  "11101110": 33,
  "11101111": 47,
  "11110000": 13,
  "11110001": 67,
  "11110010": 37,
  "11110011": 43,
  "size": 8
}, {
  "111101000": 12,
  "111101001": 52,
  "111101010": 68,
  "111101011": 28,
  "111101100": 14,
  "111101101": 66,
  "111101110": 46,
  "111101111": 34,
  "111110000": 24,
  "111110001": 60,
  "111110010": 20,
  "111110011": 56,
  "size": 9
}, {
  "1111101000": 11,
  "1111101001": 65,
  "1111101010": 25,
  "1111101011": 55,
  "1111101100": 69,
  "1111101101": 61,
  "1111101110": 15,
  "1111101111": 19,
  "1111110000": 36,
  "1111110001": 4,
  "1111110010": 77,
  "1111110011": 76,
  "size": 10
}, {
  "size": 11,
  "11111101011": 27,
  "11111101001": 44,
  "11111101111": 45,
  "11111101101": 35,
  "11111110001": 10,
  "11111110101": 78,
  "11111110111": 62,
  "11111110000": 64,
  "11111110010": 16,
  "11111101110": 5,
  "11111101000": 3,
  "11111111001": 6,
  "11111101100": 53,
  "11111111000": 70,
  "11111101010": 75,
  "11111110110": 54,
  "11111110011": 26,
  "11111110100": 2
}, {
  "size": 12,
  "111111110110": 63,
  "111111110100": 18,
  "111111111001": 71,
  "111111111100": 73,
  "111111110101": 74,
  "111111111000": 7,
  "111111111101": 9,
  "111111111011": 79,
  "111111111010": 17,
  "111111110111": 1
}, {
  "size": 13,
  "1111111111111": 0,
  "1111111111100": 72,
  "1111111111101": 8,
  "1111111111110": 80
}], [{
  "1000": 30,
  "size": 4,
  "0011": 41,
  "0000": 40,
  "0101": 50,
  "0001": 49,
  "0111": 48,
  "0010": 39,
  "0110": 32,
  "0100": 31
}, {
  "100100": 57,
  "100101": 59,
  "100110": 23,
  "100111": 21,
  "101000": 22,
  "101001": 33,
  "101010": 58,
  "101011": 47,
  "101100": 51,
  "101101": 38,
  "101110": 29,
  "101111": 42,
  "110000": 56,
  "110001": 24,
  "110010": 20,
  "110011": 60,
  "size": 6
}, {
  "1101000": 14,
  "1101001": 68,
  "1101010": 66,
  "1101011": 34,
  "1101100": 12,
  "1101101": 52,
  "1101110": 46,
  "1101111": 28,
  "1110000": 67,
  "1110001": 13,
  "1110010": 37,
  "1110011": 43,
  "1110100": 69,
  "size": 7
}, {
  "11101010": 11,
  "11101011": 25,
  "11101100": 61,
  "11101101": 65,
  "11101110": 55,
  "11101111": 19,
  "11110000": 15,
  "11110001": 70,
  "size": 8
}, {
  "111100100": 64,
  "111100101": 10,
  "111100110": 16,
  "111100111": 45,
  "111101000": 27,
  "111101001": 77,
  "111101010": 5,
  "111101011": 3,
  "111101100": 53,
  "111101101": 75,
  "111101110": 35,
  "111101111": 36,
  "111110000": 6,
  "111110001": 2,
  "111110010": 62,
  "111110011": 18,
  "111110100": 4,
  "111110101": 78,
  "111110110": 74,
  "111110111": 26,
  "111111000": 76,
  "111111001": 54,
  "111111010": 44,
  "size": 9
}, {
  "1111110110": 9,
  "1111110111": 17,
  "1111111000": 63,
  "1111111001": 73,
  "1111111010": 71,
  "1111111011": 79,
  "1111111100": 7,
  "1111111101": 1,
  "size": 10
}, {
  "size": 11,
  "11111111110": 0,
  "11111111111": 72,
  "11111111101": 8,
  "11111111100": 80
}], [{
  "0": 0,
  "size": 1
}, {
  "100": 8,
  "101": 1,
  "size": 3
}, {
  "1100": 9,
  "size": 4
}, {
  "110100": 17,
  "110101": 10,
  "110110": 16,
  "110111": 2,
  "size": 6
}, {
  "1110000": 25,
  "1110001": 11,
  "1110010": 18,
  "1110011": 24,
  "1110100": 3,
  "size": 7
}, {
  "11101010": 19,
  "11101011": 26,
  "11101100": 12,
  "11101101": 33,
  "11101110": 13,
  "11101111": 41,
  "11110000": 27,
  "11110001": 20,
  "11110010": 4,
  "11110011": 32,
  "size": 8
}, {
  "111101000": 34,
  "111101001": 21,
  "111101010": 42,
  "111101011": 5,
  "111101100": 49,
  "111101101": 40,
  "111101110": 14,
  "111101111": 35,
  "111110000": 29,
  "111110001": 28,
  "111110010": 43,
  "111110011": 22,
  "111110100": 50,
  "111110101": 15,
  "size": 9
}, {
  "1111101100": 30,
  "1111101101": 6,
  "1111101110": 48,
  "1111101111": 36,
  "1111110000": 57,
  "1111110001": 37,
  "1111110010": 58,
  "1111110011": 44,
  "1111110100": 51,
  "1111110101": 23,
  "1111110110": 59,
  "1111110111": 52,
  "1111111000": 45,
  "1111111001": 38,
  "1111111010": 31,
  "size": 10
}, {
  "size": 11,
  "11111111011": 39,
  "11111111100": 47,
  "11111111101": 61,
  "11111111010": 60,
  "11111110110": 56,
  "11111111001": 46,
  "11111111000": 53,
  "11111110111": 7
}, {
  "size": 12,
  "111111111110": 55,
  "111111111101": 54,
  "111111111100": 62,
  "111111111111": 63
}], [{
  "size": 3,
  "000": 9
}, {
  "size": 4,
  "0101": 1,
  "0011": 8,
  "0100": 10,
  "0010": 17,
  "0110": 18
}, {
  "10000": 2,
  "10001": 25,
  "10010": 11,
  "10011": 26,
  "10100": 19,
  "size": 5,
  "01111": 16,
  "01110": 0
}, {
  "101010": 27,
  "101011": 33,
  "101100": 12,
  "101101": 34,
  "101110": 20,
  "101111": 24,
  "110000": 3,
  "110001": 35,
  "110010": 28,
  "110011": 42,
  "size": 6
}, {
  "1101000": 41,
  "1101001": 21,
  "1101010": 13,
  "1101011": 43,
  "1101100": 29,
  "1101101": 36,
  "1101110": 44,
  "1101111": 4,
  "1110000": 37,
  "1110001": 32,
  "1110010": 22,
  "1110011": 50,
  "1110100": 49,
  "1110101": 14,
  "size": 7
}, {
  "11101100": 30,
  "11101101": 51,
  "11101110": 45,
  "11101111": 40,
  "11110000": 52,
  "11110001": 5,
  "11110010": 38,
  "11110011": 57,
  "11110100": 58,
  "11110101": 23,
  "11110110": 53,
  "11110111": 59,
  "11111000": 15,
  "11111001": 46,
  "11111010": 31,
  "size": 8
}, {
  "111110110": 54,
  "111110111": 60,
  "111111000": 48,
  "111111001": 39,
  "111111010": 6,
  "111111011": 61,
  "111111100": 62,
  "111111101": 55,
  "size": 9
}, {
  "1111111100": 47,
  "1111111101": 56,
  "1111111110": 7,
  "1111111111": 63,
  "size": 10
}], [{
  "0": 0,
  "size": 1
}, {
  "100": 13,
  "101": 1,
  "size": 3
}, {
  "1100": 14,
  "size": 4
}, {
  "110100": 27,
  "110101": 15,
  "110110": 26,
  "110111": 2,
  "size": 6
}, {
  "1110000": 40,
  "1110001": 28,
  "1110010": 16,
  "size": 7
}, {
  "11100110": 39,
  "11100111": 3,
  "11101000": 29,
  "11101001": 41,
  "11101010": 17,
  "11101011": 53,
  "11101100": 30,
  "11101101": 18,
  "size": 8
}, {
  "111011100": 54,
  "111011101": 42,
  "111011110": 4,
  "111011111": 52,
  "111100000": 66,
  "111100001": 31,
  "111100010": 19,
  "111100011": 43,
  "111100100": 67,
  "111100101": 79,
  "111100110": 55,
  "size": 9
}, {
  "1111001110": 5,
  "1111001111": 32,
  "1111010000": 65,
  "1111010001": 20,
  "1111010010": 44,
  "1111010011": 21,
  "1111010100": 105,
  "1111010101": 56,
  "1111010110": 68,
  "1111010111": 80,
  "1111011000": 92,
  "1111011001": 6,
  "1111011010": 106,
  "1111011011": 34,
  "1111011100": 45,
  "1111011101": 33,
  "1111011110": 57,
  "1111011111": 118,
  "1111100000": 22,
  "1111100001": 93,
  "size": 10
}, {
  "size": 11,
  "11111001100": 46,
  "11111011100": 60,
  "11111000101": 69,
  "11111010001": 70,
  "11111011011": 71,
  "11111100000": 73,
  "11111000100": 78,
  "11111001011": 58,
  "11111011110": 48,
  "11111000110": 81,
  "11111001111": 82,
  "11111011010": 83,
  "11111001010": 47,
  "11111011111": 144,
  "11111010011": 91,
  "11111011101": 59,
  "11111001000": 7,
  "11111010100": 94,
  "11111011001": 95,
  "11111010101": 132,
  "11111001110": 131,
  "11111010010": 104,
  "11111001101": 8,
  "11111010000": 35,
  "11111000111": 107,
  "11111010111": 108,
  "11111100010": 109,
  "11111010110": 120,
  "11111001001": 119,
  "11111100001": 117,
  "11111011000": 23
}, {
  "size": 12,
  "111111000111": 36,
  "111111010100": 37,
  "111111001101": 61,
  "111111100010": 62,
  "111111011010": 85,
  "111111100011": 86,
  "111111101001": 87,
  "111111100111": 63,
  "111111101000": 143,
  "111111100001": 135,
  "111111011100": 147,
  "111111100100": 38,
  "111111011000": 49,
  "111111101010": 50,
  "111111001100": 157,
  "111111010011": 96,
  "111111011110": 97,
  "111111010001": 134,
  "111111000110": 133,
  "111111010110": 158,
  "111111001011": 84,
  "111111100000": 130,
  "111111100110": 124,
  "111111001111": 24,
  "111111010010": 72,
  "111111010101": 25,
  "111111011001": 74,
  "111111101011": 75,
  "111111010111": 146,
  "111111001110": 110,
  "111111011011": 111,
  "111111100101": 123,
  "111111010000": 122,
  "111111001010": 121,
  "111111001001": 145,
  "111111001000": 9,
  "111111011101": 10,
  "111111011111": 159
}, {
  "size": 13,
  "1111111110100": 115,
  "1111111100110": 88,
  "1111111011000": 112,
  "1111111110110": 103,
  "1111111101011": 125,
  "1111111101111": 126,
  "1111111110001": 102,
  "1111111101010": 101,
  "1111111100010": 100,
  "1111111011001": 99,
  "1111111011101": 98,
  "1111111110111": 90,
  "1111111100000": 136,
  "1111111101000": 137,
  "1111111110000": 138,
  "1111111110011": 89,
  "1111111101110": 113,
  "1111111101001": 77,
  "1111111100011": 76,
  "1111111100001": 64,
  "1111111011100": 148,
  "1111111011111": 149,
  "1111111101101": 150,
  "1111111110101": 151,
  "1111111100111": 156,
  "1111111011011": 51,
  "1111111101100": 12,
  "1111111100100": 11,
  "1111111011110": 160,
  "1111111011010": 161,
  "1111111100101": 162,
  "1111111110010": 163
}, {
  "size": 14,
  "11111111111101": 167,
  "11111111111001": 152,
  "11111111111011": 153,
  "11111111111100": 166,
  "11111111110111": 165,
  "11111111110101": 129,
  "11111111110000": 114,
  "11111111110010": 116,
  "11111111110011": 127,
  "11111111110100": 128,
  "11111111110001": 139,
  "11111111111000": 140,
  "11111111110110": 141,
  "11111111111010": 164
}, {
  "size": 15,
  "111111111111110": 155,
  "111111111111101": 154,
  "111111111111100": 142,
  "111111111111111": 168
}], [{
  "size": 4,
  "0010": 27,
  "0000": 14,
  "0001": 15
}, {
  "size": 5,
  "01101": 42,
  "01001": 16,
  "01000": 1,
  "00111": 13,
  "00110": 28,
  "01100": 29,
  "01011": 40,
  "01010": 41
}, {
  "100000": 17,
  "100001": 53,
  "100010": 0,
  "100011": 55,
  "100100": 43,
  "100101": 39,
  "100110": 3,
  "100111": 56,
  "101000": 31,
  "101001": 67,
  "size": 6,
  "011110": 30,
  "011101": 2,
  "011100": 26,
  "011111": 54
}, {
  "1010100": 18,
  "1010101": 66,
  "1010110": 68,
  "1010111": 44,
  "1011000": 69,
  "1011001": 57,
  "1011010": 80,
  "1011011": 32,
  "1011100": 81,
  "1011101": 52,
  "1011110": 79,
  "1011111": 4,
  "1100000": 19,
  "1100001": 45,
  "1100010": 70,
  "1100011": 82,
  "1100100": 58,
  "size": 7
}, {
  "11001010": 83,
  "11001011": 93,
  "11001100": 46,
  "11001101": 33,
  "11001110": 71,
  "11001111": 106,
  "11010000": 94,
  "11010001": 65,
  "11010010": 92,
  "11010011": 5,
  "11010100": 105,
  "11010101": 20,
  "11010110": 107,
  "11010111": 95,
  "11011000": 59,
  "11011001": 34,
  "11011010": 84,
  "11011011": 96,
  "11011100": 21,
  "11011101": 47,
  "11011110": 108,
  "11011111": 60,
  "11100000": 72,
  "11100001": 109,
  "11100010": 73,
  "size": 8
}, {
  "111000110": 97,
  "111000111": 85,
  "111001000": 119,
  "111001001": 78,
  "111001010": 86,
  "111001011": 120,
  "111001100": 48,
  "111001101": 118,
  "111001110": 35,
  "111001111": 6,
  "111010000": 110,
  "111010001": 121,
  "111010010": 61,
  "111010011": 132,
  "111010100": 22,
  "111010101": 98,
  "111010110": 111,
  "111010111": 122,
  "111011000": 99,
  "111011001": 133,
  "111011010": 74,
  "111011011": 134,
  "111011100": 36,
  "111011101": 131,
  "111011110": 49,
  "111011111": 123,
  "111100000": 87,
  "111100001": 104,
  "111100010": 62,
  "111100011": 91,
  "111100100": 145,
  "size": 9
}, {
  "1111001010": 100,
  "1111001011": 146,
  "1111001100": 136,
  "1111001101": 23,
  "1111001110": 144,
  "1111001111": 124,
  "1111010000": 7,
  "1111010001": 112,
  "1111010010": 135,
  "1111010011": 50,
  "1111010100": 75,
  "1111010101": 113,
  "1111010110": 148,
  "1111010111": 8,
  "1111011000": 147,
  "1111011001": 37,
  "1111011010": 101,
  "1111011011": 88,
  "1111011100": 137,
  "1111011101": 63,
  "1111011110": 24,
  "1111011111": 158,
  "1111100000": 125,
  "1111100001": 159,
  "1111100010": 149,
  "1111100011": 76,
  "1111100100": 160,
  "1111100101": 150,
  "1111100110": 161,
  "1111100111": 51,
  "1111101000": 89,
  "1111101001": 117,
  "1111101010": 138,
  "1111101011": 130,
  "1111101100": 157,
  "1111101101": 9,
  "1111101110": 64,
  "1111101111": 126,
  "1111110000": 162,
  "1111110001": 38,
  "1111110010": 114,
  "size": 10
}, {
  "size": 11,
  "11111110111": 154,
  "11111101101": 139,
  "11111111001": 141,
  "11111101111": 164,
  "11111110010": 143,
  "11111101001": 163,
  "11111111000": 128,
  "11111100110": 127,
  "11111111011": 116,
  "11111101110": 115,
  "11111110000": 10,
  "11111110001": 103,
  "11111101000": 151,
  "11111110100": 152,
  "11111110101": 153,
  "11111110011": 140,
  "11111101011": 77,
  "11111111010": 156,
  "11111101010": 102,
  "11111110110": 11,
  "11111100111": 25,
  "11111101100": 90
}, {
  "size": 12,
  "111111111101": 12,
  "111111111011": 155,
  "111111111010": 129,
  "111111111001": 142,
  "111111111000": 165,
  "111111111110": 166,
  "111111111100": 167,
  "111111111111": 168
}], [{
  "size": 4,
  "0000": 0,
  "0001": 18
}, {
  "size": 5,
  "00110": 1,
  "01001": 36,
  "00111": 35,
  "01000": 19,
  "00100": 288,
  "00101": 17
}, {
  "size": 6,
  "011010": 54,
  "011001": 2,
  "010100": 20,
  "010110": 53,
  "010111": 34,
  "010101": 52,
  "011000": 37
}, {
  "1000000": 39,
  "1000001": 72,
  "1000010": 22,
  "1000011": 88,
  "1000100": 56,
  "1000101": 89,
  "size": 7,
  "0110110": 69,
  "0111001": 38,
  "0111100": 51,
  "0111101": 3,
  "0110111": 21,
  "0111011": 55,
  "0111000": 70,
  "0111010": 71,
  "0111110": 86,
  "0111111": 87
}, {
  "10001100": 73,
  "10001101": 104,
  "10001110": 40,
  "10001111": 103,
  "10010000": 105,
  "10010001": 57,
  "10010010": 23,
  "10010011": 84,
  "10010100": 67,
  "10010101": 277,
  "10010110": 275,
  "10010111": 276,
  "10011000": 106,
  "10011001": 278,
  "10011010": 68,
  "10011011": 74,
  "10011100": 4,
  "10011101": 50,
  "10011110": 90,
  "10011111": 101,
  "10100000": 279,
  "10100001": 274,
  "10100010": 280,
  "10100011": 41,
  "10100100": 121,
  "10100101": 58,
  "10100110": 107,
  "10100111": 91,
  "10101000": 118,
  "10101001": 282,
  "10101010": 122,
  "10101011": 120,
  "10101100": 281,
  "10101101": 135,
  "10101110": 33,
  "10101111": 24,
  "10110000": 75,
  "10110001": 283,
  "10110010": 123,
  "10110011": 284,
  "10110100": 152,
  "10110101": 273,
  "10110110": 108,
  "10110111": 169,
  "10111000": 42,
  "10111001": 92,
  "10111010": 186,
  "10111011": 285,
  "10111100": 139,
  "10111101": 138,
  "10111110": 59,
  "10111111": 85,
  "11000000": 286,
  "11000001": 203,
  "11000010": 124,
  "11000011": 76,
  "11000100": 109,
  "11000101": 125,
  "11000110": 5,
  "size": 8
}, {
  "110001110": 140,
  "110001111": 287,
  "110010000": 220,
  "110010001": 25,
  "110010010": 137,
  "110010011": 254,
  "110010100": 93,
  "110010101": 237,
  "110010110": 60,
  "110010111": 141,
  "110011000": 126,
  "110011001": 43,
  "110011010": 142,
  "110011011": 155,
  "110011100": 156,
  "110011101": 271,
  "110011110": 77,
  "110011111": 110,
  "110100000": 102,
  "110100001": 157,
  "110100010": 94,
  "110100011": 143,
  "110100100": 127,
  "110100101": 26,
  "110100110": 173,
  "110100111": 6,
  "110101000": 172,
  "110101001": 154,
  "110101010": 158,
  "110101011": 78,
  "110101100": 44,
  "110101101": 159,
  "110101110": 61,
  "110101111": 111,
  "110110000": 174,
  "110110001": 144,
  "110110010": 175,
  "110110011": 160,
  "110110100": 190,
  "110110101": 27,
  "110110110": 119,
  "110110111": 176,
  "110111000": 128,
  "110111001": 62,
  "110111010": 95,
  "110111011": 171,
  "110111100": 79,
  "110111101": 189,
  "110111110": 223,
  "110111111": 112,
  "111000000": 224,
  "111000001": 45,
  "111000010": 272,
  "111000011": 96,
  "111000100": 192,
  "size": 9
}, {
  "1110001010": 191,
  "1110001011": 161,
  "1110001100": 129,
  "1110001101": 145,
  "1110001110": 16,
  "1110001111": 81,
  "1110010000": 7,
  "1110010001": 64,
  "1110010010": 193,
  "1110010011": 222,
  "1110010100": 225,
  "1110010101": 207,
  "1110010110": 47,
  "1110010111": 226,
  "1110011000": 146,
  "1110011001": 113,
  "1110011010": 178,
  "1110011011": 177,
  "1110011100": 240,
  "1110011101": 208,
  "1110011110": 28,
  "1110011111": 80,
  "1110100000": 188,
  "1110100001": 63,
  "1110100010": 30,
  "1110100011": 206,
  "1110100100": 130,
  "1110100101": 65,
  "1110100110": 97,
  "1110100111": 98,
  "1110101000": 242,
  "1110101001": 82,
  "1110101010": 194,
  "1110101011": 241,
  "1110101100": 209,
  "1110101101": 227,
  "1110101110": 210,
  "1110101111": 136,
  "1110110000": 195,
  "1110110001": 46,
  "1110110010": 162,
  "1110110011": 243,
  "1110110100": 115,
  "1110110101": 180,
  "1110110110": 257,
  "1110110111": 147,
  "1110111000": 163,
  "1110111001": 244,
  "1110111010": 179,
  "1110111011": 99,
  "1110111100": 196,
  "1110111101": 239,
  "1110111110": 48,
  "1110111111": 114,
  "1111000000": 29,
  "1111000001": 229,
  "1111000010": 8,
  "1111000011": 228,
  "1111000100": 131,
  "1111000101": 211,
  "1111000110": 132,
  "1111000111": 258,
  "1111001000": 205,
  "1111001001": 116,
  "1111001010": 49,
  "1111001011": 260,
  "1111001100": 259,
  "1111001101": 31,
  "1111001110": 164,
  "1111001111": 83,
  "1111010000": 245,
  "1111010001": 149,
  "1111010010": 230,
  "1111010011": 148,
  "1111010100": 100,
  "1111010101": 66,
  "1111010110": 181,
  "1111010111": 197,
  "1111011000": 212,
  "1111011001": 261,
  "1111011010": 262,
  "1111011011": 150,
  "1111011100": 256,
  "1111011101": 133,
  "1111011110": 153,
  "1111011111": 9,
  "1111100000": 166,
  "1111100001": 165,
  "1111100010": 213,
  "1111100011": 246,
  "1111100100": 183,
  "1111100101": 247,
  "1111100110": 214,
  "1111100111": 117,
  "1111101000": 134,
  "size": 10
}, {
  "size": 11,
  "11111111000": 238,
  "11111110100": 235,
  "11111101011": 234,
  "11111011111": 233,
  "11111011001": 232,
  "11111011010": 231,
  "11111110010": 221,
  "11111110111": 219,
  "11111100010": 248,
  "11111011110": 249,
  "11111101101": 250,
  "11111110001": 251,
  "11111111001": 252,
  "11111111100": 253,
  "11111101001": 218,
  "11111100110": 10,
  "11111100000": 217,
  "11111100111": 216,
  "11111100100": 215,
  "11111111011": 204,
  "11111110000": 202,
  "11111010101": 201,
  "11111011011": 200,
  "11111010011": 263,
  "11111111010": 236,
  "11111101110": 265,
  "11111101111": 266,
  "11111110101": 267,
  "11111110110": 268,
  "11111110011": 11,
  "11111101100": 13,
  "11111011100": 199,
  "11111010100": 198,
  "11111101000": 187,
  "11111101010": 185,
  "11111011000": 184,
  "11111010111": 182,
  "11111100011": 170,
  "11111100101": 168,
  "11111010010": 167,
  "11111011101": 151,
  "11111010110": 32,
  "11111100001": 264
}, {
  "size": 12,
  "111111111110": 15,
  "111111111010": 14,
  "111111111111": 270,
  "111111111011": 12,
  "111111111100": 269,
  "111111111101": 255
}]];
exports.spectrumCB = spectrumCB;
},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _libExpGolombString = require('../../lib/exp-golomb-string');

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var _libRbspUtils = require('../../lib/rbsp-utils');

var _scaleFactorBands = require('./scale-factor-bands');

var _codebooks = require('./codebooks');

var ONLY_LONG_SEQUENCE = 0;
var LONG_START_SEQUENCE = 1;
var EIGHT_SHORT_SEQUENCE = 2;
var LONG_STOP_SEQUENCE = 3;

var QUAD_LEN = 4;
var PAIR_LEN = 2;
var ZERO_HCB = 0;
var FIRST_PAIR_HCB = 5;
var ESC_HCB = 11;
var NOISE_HCB = 13;
var INTENSITY_HCB2 = 14;
var INTENSITY_HCB = 15;
var ESC_FLAG = 16;

var codebookInfo = [
// [unsigned, tuples, LAV]
[null, null, 0], // ZERO_HCB
[0, 4, 1], [0, 4, 1], [1, 4, 2], [1, 4, 2], [0, 2, 4], // FIRST_PAIR_HCB
[0, 2, 4], [1, 2, 7], [1, 2, 7], [1, 2, 12], [1, 2, 12], [1, 2, 16] // ESC_HCB
];

var PRED_SFB_MAX = [33, 33, 38, 40, 40, 40, 41, 41, 37, 37, 37, 34];

var bit_set = function bit_set(val, bit) {
  return 1 << bit & val;
};

var doPostIcsInfoCalculation = {
  decode: function decode(expGolomb, output, options, index) {
    var fs_index = options.sampling_frequency_index;

    if (output.window_sequence === EIGHT_SHORT_SEQUENCE) {
      output.num_windows = 8;
      output.num_window_groups = 1;
      output.window_group_length = [1];
      output.num_swb = _scaleFactorBands.swb_offset_long_window[fs_index].length - 1;
      output.sect_sfb_offset = [];
      output.swb_offset = [];

      for (var i = 0; i <= output.num_swb; i++) {
        output.swb_offset[i] = _scaleFactorBands.swb_offset_short_window[fs_index][i];
      }

      for (var i = 0; i < output.num_windows - 1; i++) {
        if (bit_set(output.scale_factor_grouping, 6 - i) === 0) {
          output.num_window_groups += 1;
          output.window_group_length[output.num_window_groups - 1] = 1;
        } else {
          output.window_group_length[output.num_window_groups - 1] += 1;
        }
      }

      /* preparation of sect_sfb_offset for short blocks */
      for (var g = 0; g < output.num_window_groups; g++) {
        var sect_sfb = 0;
        var offset = 0;
        output.sect_sfb_offset[g] = [];
        for (var i = 0; i < output.max_sfb; i++) {
          var width = _scaleFactorBands.swb_offset_short_window[fs_index][i + 1] - _scaleFactorBands.swb_offset_short_window[fs_index][i];
          width *= output.window_group_length[g];
          output.sect_sfb_offset[g][sect_sfb++] = offset;
          offset += width;
        }
        output.sect_sfb_offset[g][sect_sfb] = offset;
      }
    } else {
      output.num_windows = 1;
      output.num_window_groups = 1;
      output.window_group_length = [1];
      output.num_swb = _scaleFactorBands.swb_offset_long_window[fs_index].length - 1;
      output.sect_sfb_offset = [[]];
      output.swb_offset = [];

      for (var i = 0; i <= output.max_sfb; i++) {
        output.sect_sfb_offset[0][i] = _scaleFactorBands.swb_offset_long_window[fs_index][i];
        output.swb_offset[i] = _scaleFactorBands.swb_offset_long_window[fs_index][i];
      }
    }

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var sectionData = {
  decode: function decode(expGolomb, output, options, index) {
    var bits = 5;
    if (output.window_sequence === EIGHT_SHORT_SEQUENCE) {
      bits = 3;
    }

    var sect_esc_val = (1 << bits) - 1;
    output.sect_cb = [];
    output.sect_start = [];
    output.sect_end = [];
    output.sfb_cb = [];
    output.num_sec = [];
    for (var g = 0; g < output.num_window_groups; g++) {
      var k = 0;
      var i = 0;

      output.sect_cb[g] = [];
      output.sect_start[g] = [];
      output.sect_end[g] = [];
      output.sfb_cb[g] = [];

      while (k < output.max_sfb) {
        output.sect_cb[g][i] = expGolomb.readBits(4);
        var sect_len = 0;
        var sect_len_part = 0;

        do {
          sect_len_part = expGolomb.readBits(bits);
          sect_len += sect_len_part;
        } while (sect_len_part === sect_esc_val);

        output.sect_start[g][i] = k;
        output.sect_end[g][i] = k + sect_len;
        for (var sfb = k; sfb < k + sect_len; sfb++) {
          output.sfb_cb[g][sfb] = output.sect_cb[g][i];
        }
        k += sect_len;
        i++;
      }
      output.num_sec[g] = i;
    }

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var scaleFactorData = {
  decode: function decode(expGolomb, output, options, index) {
    output.scale_factors = [];

    for (var g = 0; g < output.num_window_groups; g++) {
      for (var sfb = 0; sfb < output.max_sfb; sfb++) {
        if (output.sfb_cb[g][sfb] !== ZERO_HCB) {
          output.scale_factors.push((0, _codebooks.readCodebookValue)(_codebooks.scaleFactorCB, expGolomb));
        }
      }
    }
    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var tnsData = {
  decode: function decode(expGolomb, output, options, index) {
    output.n_filt = [];
    output.coef_res = [];
    output.length = [];
    output.order = [];
    output.direction = [];
    output.coef_compress = [];
    output.coef = [];

    for (var w = 0; w < output.num_windows; w++) {
      output.n_filt[w] = expGolomb.readBits(2);
      output.length[w] = [];
      output.order[w] = [];
      output.direction[w] = [];
      output.coef_compress[w] = [];
      output.coef[w] = [];

      if (output.n_filt[w]) {
        output.coef_res[w] = expGolomb.readBits(1);
      }

      for (var filt = 0; filt < output.n_filt[w]; filt++) {
        output.length[w][filt] = expGolomb.readBits(6);
        output.order[w][filt] = expGolomb.readBits(5);
        if (output.order[w][filt]) {
          output.direction[w][filt] = expGolomb.readBits(1);
          output.coef_compress[w][filt] = expGolomb.readBits(1);
          output.coef[w][filt] = [];
          for (var i = 0; i < output.order[w][filt]; i++) {
            output.coef[w][filt][i] = expGolomb.readBits(output.coef_res[w] + 3);
          }
        }
      }
    }

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var gainControlData = {
  decode: function decode(expGolomb, output, options, index) {
    output.max_band = expGolomb.readBits(2);
    output.adjust_num = [];
    output.alevcode = [];
    output.aloccode = [];

    if (output.window_sequence === ONLY_LONG_SEQUENCE) {
      for (var bd = 1; bd <= output.max_band; bd++) {
        output.adjust_num[bd] = [];
        output.alevcode[bd] = [];
        output.aloccode[bd] = [];
        for (var wd = 0; wd < 1; wd++) {
          output.adjust_num[bd][wd] = expGolomb.readBits(3);
          output.alevcode[bd][wd] = [];
          output.aloccode[bd][wd] = [];
          for (var ad = 0; ad < output.adjust_num[bd][wd]; ad++) {
            output.alevcode[bd][wd][ad] = expGolomb.readBits(4);
            output.aloccode[bd][wd][ad] = expGolomb.readBits(5);
          }
        }
      }
    } else if (output.window_sequence === LONG_START_SEQUENCE) {
      for (var bd = 1; bd <= output.max_band; bd++) {
        output.adjust_num[bd] = [];
        output.alevcode[bd] = [];
        output.aloccode[bd] = [];
        for (var wd = 0; wd < 2; wd++) {
          output.adjust_num[bd][wd] = expGolomb.readBits(3);
          output.alevcode[bd][wd] = [];
          output.aloccode[bd][wd] = [];
          for (var ad = 0; ad < output.adjust_num[bd][wd]; ad++) {
            output.alevcode[bd][wd][ad] = expGolomb.readBits(4);

            if (wd === 0) {
              output.aloccode[bd][wd][ad] = expGolomb.readBits(4);
            } else {
              output.aloccode[bd][wd][ad] = expGolomb.readBits(2);
            }
          }
        }
      }
    } else if (output.window_sequence === EIGHT_SHORT_SEQUENCE) {
      for (var bd = 1; bd <= output.max_band; bd++) {
        output.adjust_num[bd] = [];
        output.alevcode[bd] = [];
        output.aloccode[bd] = [];
        for (var wd = 0; wd < 8; wd++) {
          output.adjust_num[bd][wd] = expGolomb.readBits(3);
          output.alevcode[bd][wd] = [];
          output.aloccode[bd][wd] = [];
          for (var ad = 0; ad < output.adjust_num[bd][wd]; ad++) {
            output.alevcode[bd][wd][ad] = expGolomb.readBits(4);
            output.aloccode[bd][wd][ad] = expGolomb.readBits(2);
          }
        }
      }
    } else if (output.window_sequence === LONG_STOP_SEQUENCE) {
      for (var bd = 1; bd <= output.max_band; bd++) {
        output.adjust_num[bd] = [];
        output.alevcode[bd] = [];
        output.aloccode[bd] = [];
        for (var wd = 0; wd < 2; wd++) {
          output.adjust_num[bd][wd] = expGolomb.readBits(3);
          output.alevcode[bd][wd] = [];
          output.aloccode[bd][wd] = [];
          for (var ad = 0; ad < output.adjust_num[bd][wd]; ad++) {
            output.alevcode[bd][wd][ad] = expGolomb.readBits(4);

            if (wd === 0) {
              output.aloccode[bd][wd][ad] = expGolomb.readBits(4);
            } else {
              output.aloccode[bd][wd][ad] = expGolomb.readBits(5);
            }
          }
        }
      }
    }
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var decodeHCode = function decodeHCode(idx, sect_cb) {
  var _codebookInfo$sect_cb = _slicedToArray(codebookInfo[sect_cb], 3);

  var unsigned = _codebookInfo$sect_cb[0];
  var dim = _codebookInfo$sect_cb[1];
  var lav = _codebookInfo$sect_cb[2];

  var mod = undefined,
      off = undefined;
  var v = undefined;
  var vals = [];

  if (unsigned) {
    mod = lav + 1;
    off = 0;
  } else {
    mod = 2 * lav + 1;
    off = lav;
  }

  if (dim === 4) {
    vals.push(v = parseInt(idx / (mod * mod * mod)) - off);
    idx -= (v + off) * (mod * mod * mod);
    vals.push(v = parseInt(idx / (mod * mod)) - off);
    idx -= (v + off) * (mod * mod);
    vals.push(v = parseInt(idx / mod) - off);
    idx -= (v + off) * mod;
    vals.push(idx - off);
  } else {
    vals.push(v = parseInt(idx / mod) - off);
    idx -= (v + off) * mod;
    vals.push(idx - off);
  }
  return vals;
};

var getSignBits = function getSignBits(vals, sect_cb) {
  var _codebookInfo$sect_cb2 = _slicedToArray(codebookInfo[sect_cb], 1);

  var unsigned = _codebookInfo$sect_cb2[0];

  if (!unsigned) {
    return 0;
  } else {
    return vals.filter(function (v) {
      return v !== 0;
    }).length;
  }
};

var readEscValue = function readEscValue(expGolomb) {
  var bits = expGolomb.bitReservoir;
  var N = 0;

  for (N = 0; N < bits.length; N++) {
    if (bits[N] === '0') {
      var esc = expGolomb.readBits(N + 1);
      var _val = expGolomb.readBits(N + 4);

      return Math.pow(2, N + 4) + _val;
    }
  }
};

var spectralData = {
  decode: function decode(expGolomb, output, options, index) {
    output.spectral_data = [];
    for (var g = 0; g < output.num_window_groups; g++) {
      output.spectral_data[g] = [];
      for (var i = 0; i < output.num_sec[g]; i++) {
        var sect_cb = output.sect_cb[g][i];
        var start_k = output.sect_sfb_offset[g][output.sect_start[g][i]];
        var end_k = output.sect_sfb_offset[g][output.sect_end[g][i]];

        if (sect_cb !== ZERO_HCB && sect_cb <= ESC_HCB) {
          for (var k = start_k; k < end_k;) {
            var idx = (0, _codebooks.readCodebookValue)(_codebooks.spectrumCB[sect_cb], expGolomb);
            var vals = decodeHCode(idx, sect_cb);
            var numBits = getSignBits(vals, sect_cb);

            // Read sign bits
            var bits = expGolomb.readRawBits(numBits);

            output.spectral_data[g][k] = vals[0];
            output.spectral_data[g][k + 1] = vals[1];
            if (sect_cb < FIRST_PAIR_HCB) {
              output.spectral_data[g][k + 2] = vals[2];
              output.spectral_data[g][k + 3] = vals[3];
              k += QUAD_LEN;
            } else {
              if (sect_cb === ESC_HCB) {
                if (vals[0] === ESC_FLAG) {
                  output.spectral_data[g][k] = readEscValue(expGolomb);
                }
                if (vals[1] === ESC_FLAG) {
                  output.spectral_data[g][k + 1] = readEscValue(expGolomb);
                }
              }
              k += PAIR_LEN;
            }
          }
        }
      }
    }

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var readMsMask = {
  decode: function decode(expGolomb, output, options, index) {
    output.ms_used = [];

    for (var g = 0; g < output.num_window_groups; g++) {
      output.ms_used[g] = [];
      for (var sfb = 0; sfb < output.max_sfb; sfb++) {
        output.ms_used[g][sfb] = expGolomb.readBits(1);
      }
    }

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {}
};

var icsInfo = (0, _libCombinators.list)([(0, _libCombinators.data)('ics_reserved_bit', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('window_sequence', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('window_shape', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('window_sequence', EIGHT_SHORT_SEQUENCE), (0, _libCombinators.list)([(0, _libCombinators.data)('max_sfb', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('scale_factor_grouping', (0, _libDataTypes.u)(7))])), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('window_sequence', EIGHT_SHORT_SEQUENCE)), (0, _libCombinators.list)([(0, _libCombinators.data)('max_sfb', (0, _libDataTypes.u)(6)), (0, _libCombinators.data)('predictor_data_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('predictor_data_present', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('predictor_reset', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('predictor_reset', 1), (0, _libCombinators.data)('predictor_reset_group_number', (0, _libDataTypes.u)(5))), (0, _libConditionals.each)(function (index, options) {
  return index < Math.min(options.max_sfb, PRED_SFB_MAX[options.sampling_frequency_index]);
}, (0, _libCombinators.data)('prediction_used[]', (0, _libDataTypes.u)(1)))]))])), doPostIcsInfoCalculation]);

var pulseData = (0, _libCombinators.list)([(0, _libCombinators.data)('number_pulse', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('pulse_start_sfb', (0, _libDataTypes.u)(6)), (0, _libConditionals.each)(function (index, options) {
  return index <= options.number_pulse;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('pulse_offset[]', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('pulse_amp[]', (0, _libDataTypes.u)(4))]))]);

var individualChannelStream = (0, _libCombinators.list)([(0, _libCombinators.data)('global_gain', (0, _libDataTypes.u)(8)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('common_window', 1)), icsInfo), sectionData, scaleFactorData, (0, _libCombinators.data)('pulse_data_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('pulse_data_present', 1), pulseData), (0, _libCombinators.data)('tns_data_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('tns_data_present', 1), tnsData), (0, _libCombinators.data)('gain_control_data_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('gain_control_data_present', 1), gainControlData), spectralData]);

var noop = { decode: function decode() {} };

var elemTypes = ['single_channel_element', 'channel_pair_element', 'coupling_channel_element', 'lfe_channel_element', 'data_stream_element', 'program_config_element', 'fill_element', 'end'];

var elemParsers = [(0, _libCombinators.list)([// single_channel_element
(0, _libCombinators.data)('element_instance_tag', (0, _libDataTypes.u)(4)), individualChannelStream]), (0, _libCombinators.list)([// channel_pair_element
(0, _libCombinators.data)('element_instance_tag', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('common_window', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('common_window', 1), (0, _libCombinators.list)([icsInfo, (0, _libCombinators.data)('ms_mask_present', (0, _libDataTypes.u)(2)), (0, _libConditionals.when)((0, _libConditionals.equals)('ms_mask_present', 1), readMsMask)])), (0, _libCombinators.newObj)('ics_1', (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)('individual_channel_stream')), individualChannelStream])), (0, _libCombinators.newObj)('ics_2', (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)('individual_channel_stream')), individualChannelStream]))]), noop, // coupling_channel_element
(0, _libCombinators.list)([// lfe_channel_element
(0, _libCombinators.data)('element_instance_tag', (0, _libDataTypes.u)(4)), individualChannelStream]), (0, _libCombinators.list)([// data_stream_element
(0, _libCombinators.data)('element_instance_tag', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('data_byte_align_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('count', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('esc_count', (0, _libDataTypes.val)(0)), (0, _libConditionals.when)((0, _libConditionals.equals)('count', 255), (0, _libCombinators.data)('esc_count', (0, _libDataTypes.u)(8))), (0, _libConditionals.when)((0, _libConditionals.equals)('data_byte_align_flag', 1), (0, _libCombinators.data)('byte_alignment_bits', _libDataTypes.byteAlign)), (0, _libConditionals.each)(function (index, options) {
  return index < options.count + options.esc_count;
}, (0, _libCombinators.data)('data_stream_byte[]', (0, _libDataTypes.u)(8)))]), (0, _libCombinators.list)([// program_config_element
(0, _libCombinators.data)('element_instance_tag', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('profile', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('sampling_frequency_index', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('num_front_channel_elements', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('num_side_channel_elements', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('num_back_channel_elements', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('num_lfe_channel_elements', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('num_assoc_data_elements', (0, _libDataTypes.u)(3)), (0, _libCombinators.data)('num_valid_cc_elements', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('mono_mixdown_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('mono_mixdown_present', 1), (0, _libCombinators.data)('mono_mixdown_element_number', (0, _libDataTypes.u)(4))), (0, _libCombinators.data)('stereo_mixdown_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('stereo_mixdown_present', 1), (0, _libCombinators.data)('stereo_mixdown_element_number', (0, _libDataTypes.u)(4))), (0, _libCombinators.data)('matrix_mixdown_idx_present', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('matrix_mixdown_idx_present', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('matrix_mixdown_idx', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('pseudo_surround_enable', (0, _libDataTypes.u)(1))])), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_front_channel_elements;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('front_element_is_cpe[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('front_element_tag_select[]', (0, _libDataTypes.u)(4))])), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_side_channel_elements;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('side_element_is_cpe[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('side_element_tag_select[]', (0, _libDataTypes.u)(4))])), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_back_channel_elements;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('back_element_is_cpe[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('back_element_tag_select[]', (0, _libDataTypes.u)(4))])), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_lfe_channel_elements;
}, (0, _libCombinators.data)('lfe_element_tag_select[]', (0, _libDataTypes.u)(4))), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_assoc_data_elements;
}, (0, _libCombinators.data)('assoc_data_element_tag_select[]', (0, _libDataTypes.u)(4))), (0, _libConditionals.each)(function (index, options) {
  return index < options.num_valid_cc_elements;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('cc_element_is_ind_sw[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('valid_cc_element_tag_select[]', (0, _libDataTypes.u)(4))])), (0, _libCombinators.data)('byte_alignment_bits', (0, _libDataTypes.byteAlign)()), (0, _libCombinators.data)('comment_field_bytes', (0, _libDataTypes.u)(8)), (0, _libConditionals.each)(function (index, options) {
  return index < options.comment_field_bytes;
}, (0, _libCombinators.data)('comment_field_data[]', (0, _libDataTypes.u)(8)))]), (0, _libCombinators.list)([// fill_element
(0, _libCombinators.data)('count', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('esc_count', (0, _libDataTypes.val)(0)), (0, _libConditionals.when)((0, _libConditionals.equals)('count', 15), (0, _libCombinators.data)('esc_count', (0, _libDataTypes.u)(8))), (0, _libConditionals.each)(function (index, options) {
  return index < options.count + options.esc_count - 1;
}, (0, _libCombinators.data)('fill_byte[]', (0, _libDataTypes.u)(8)))]), (0, _libCombinators.list)([// end
(0, _libCombinators.data)('byte_alignment_bits', (0, _libDataTypes.byteAlign)())])];

var aacCodec = (0, _libCombinators.start)('elements', (0, _libConditionals.whileMoreData)((0, _libCombinators.newObj)('elements[]', (0, _libCombinators.list)([(0, _libCombinators.data)('id_syn_ele', (0, _libDataTypes.u)(3)), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 0), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[0])), elemParsers[0]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[1])), elemParsers[1]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 2), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[2])), elemParsers[2]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 3), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[3])), elemParsers[3]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 4), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[4])), elemParsers[4]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 5), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[5])), elemParsers[5]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 6), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[6])), elemParsers[6]])), (0, _libConditionals.when)((0, _libConditionals.equals)('id_syn_ele', 7), (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)(elemTypes[7])), elemParsers[7]]))]))));

exports.aacCodec = aacCodec;
var adts_error_check = (0, _libConditionals.when)((0, _libConditionals.equals)('protection_absent', 0), (0, _libCombinators.data)('crc_check', (0, _libDataTypes.u)(16)));

var adts_header_error_check = (0, _libCombinators.list)([(0, _libConditionals.when)((0, _libConditionals.equals)('protection_absent', 0), (0, _libConditionals.each)(function (index, options, output) {
  return index < output.number_of_raw_data_blocks_in_frame;
}, (0, _libCombinators.data)('raw_data_block_position[]', (0, _libDataTypes.u)(16)))), adts_error_check]);

var adtsCodec = (0, _libCombinators.start)('adts_frame', (0, _libCombinators.list)([(0, _libCombinators.data)('sync_word', (0, _libDataTypes.u)(12)), (0, _libCombinators.data)('ID', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('layer', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('protection_absent', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('profile', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('sampling_frequency_index', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('private_bit', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('channel_configuration', (0, _libDataTypes.u)(3)), (0, _libCombinators.data)('original_copy', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('home', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('copyright_identification_bit', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('copyright_identification_start', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('aac_frame_length', (0, _libDataTypes.u)(13)), (0, _libCombinators.data)('adts_buffer_fullness', (0, _libDataTypes.u)(11)), (0, _libCombinators.data)('number_of_raw_data_blocks_in_frame', (0, _libDataTypes.u)(2)), (0, _libConditionals.when)((0, _libConditionals.equals)('number_of_raw_data_blocks_in_frame', 0), (0, _libCombinators.list)([adts_error_check, aacCodec])), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('number_of_raw_data_blocks_in_frame', 0)), (0, _libCombinators.list)([adts_header_error_check, (0, _libConditionals.each)(function (index, options, output) {
  return index <= output.number_of_raw_data_blocks_in_frame;
}, (0, _libCombinators.list)([(0, _libCombinators.newObj)('frames[]', aacCodec), adts_error_check]))]))]));
exports.adtsCodec = adtsCodec;
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"../../lib/exp-golomb-string":25,"../../lib/rbsp-utils":27,"./codebooks":1,"./scale-factor-bands":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var swb_offset_long_window = [[// 96k
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024], [// 88.2k
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024], [// 64k
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344, 384, 424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024], [// 48khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024], [// 44.1khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024], [// 32khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024], [// 24khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024], [// 22.05khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024], [// 16khz
0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024], [// 12khz
0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024], [// 11.025khz
0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024], [// 8khz
0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372, 396, 420, 448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024]];

exports.swb_offset_long_window = swb_offset_long_window;
var swb_offset_short_window = [[// 96khz
0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128], [// 88.2khz
0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128], [// 64khz
0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128], [// 48khz
0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128], [// 44.1khz
0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128], [// 32khz
0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128], [// 24khz
0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128], [// 22.05khz
0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128], [// 16khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128], [// 12khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128], [// 11.025khz
0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128], [// 8khz
0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 60, 72, 88, 108, 128]];

exports.swb_offset_short_window = swb_offset_short_window;
var ADTS_SAMPLING_FREQUENCIES = [
////  96000,
////  88200,
////  64000,
////  48000,
////  44100,
////  32000,
////  24000,
////  22050,
////  16000,
////  12000,
////  11025,
////  8000,
7350];
},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _libCombinators = require('../../lib/combinators');

var _libDataTypes = require('../../lib/data-types');

var audCodec = (0, _libCombinators.start)('access_unit_delimiter', (0, _libCombinators.list)([(0, _libCombinators.data)('primary_pic_type', (0, _libDataTypes.u)(3)), (0, _libCombinators.verify)('access_unit_delimiter')]));

exports['default'] = audCodec;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/data-types":23}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libCombinators = require('../../lib/combinators');

var _libDataTypes = require('../../lib/data-types');

var _libConditionals = require('../../lib/conditionals');

var _scalingList = require('./scaling-list');

var _scalingList2 = _interopRequireDefault(_scalingList);

var v = null;

var hdrParameters = (0, _libCombinators.list)([(0, _libCombinators.data)('cpb_cnt_minus1', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('bit_rate_scale', (0, _libDataTypes.u)(4)), (0, _libCombinators.data)('cpb_size_scale', (0, _libDataTypes.u)(4)), (0, _libConditionals.each)(function (index, output) {
  return index <= output.cpb_cnt_minus1;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('bit_rate_value_minus1[]', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('cpb_size_value_minus1[]', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('cbr_flag[]', (0, _libDataTypes.u)(1))])), (0, _libCombinators.data)('initial_cpb_removal_delay_length_minus1', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('cpb_removal_delay_length_minus1', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('dpb_output_delay_length_minus1', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('time_offset_length', (0, _libDataTypes.u)(5))]);

exports['default'] = hdrParameters;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"./scaling-list":8}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _accessUnitDelimiter = require('./access-unit-delimiter');

var _accessUnitDelimiter2 = _interopRequireDefault(_accessUnitDelimiter);

var _seqParameterSet = require('./seq-parameter-set');

var _seqParameterSet2 = _interopRequireDefault(_seqParameterSet);

var _picParameterSet = require('./pic-parameter-set');

var _picParameterSet2 = _interopRequireDefault(_picParameterSet);

var _sliceLayerWithoutPartitioning = require('./slice-layer-without-partitioning');

var _sliceLayerWithoutPartitioning2 = _interopRequireDefault(_sliceLayerWithoutPartitioning);

var _libDiscardEmulationPrevention = require('../../lib/discard-emulation-prevention');

var _libDiscardEmulationPrevention2 = _interopRequireDefault(_libDiscardEmulationPrevention);

var _supplementalEnhancementInformation = require('./supplemental-enhancement-information');

var _supplementalEnhancementInformation2 = _interopRequireDefault(_supplementalEnhancementInformation);

var h264Codecs = {
  accessUnitDelimiter: _accessUnitDelimiter2['default'],
  seqParameterSet: _seqParameterSet2['default'],
  picParameterSet: _picParameterSet2['default'],
  sliceLayerWithoutPartitioning: _sliceLayerWithoutPartitioning2['default'],
  discardEmulationPrevention: _libDiscardEmulationPrevention2['default'],
  supplementalEnhancementInformation: _supplementalEnhancementInformation2['default']
};

exports['default'] = h264Codecs;
module.exports = exports['default'];
},{"../../lib/discard-emulation-prevention":24,"./access-unit-delimiter":4,"./pic-parameter-set":7,"./seq-parameter-set":9,"./slice-layer-without-partitioning":11,"./supplemental-enhancement-information":12}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var _scalingList = require('./scaling-list');

var _scalingList2 = _interopRequireDefault(_scalingList);

var v = null;

var ppsCodec = (0, _libCombinators.start)('pic_parameter_set', (0, _libCombinators.list)([(0, _libCombinators.data)('pic_parameter_set_id', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('seq_parameter_set_id', (0, _libDataTypes.ue)(v)),
//    pickOptions('sps', 'seq_parameter_set_id'),
(0, _libCombinators.data)('entropy_coding_mode_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('bottom_field_pic_order_in_frame_present_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('num_slice_groups_minus1', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('num_slice_groups_minus1', 0)), (0, _libCombinators.list)([(0, _libCombinators.data)('slice_group_map_type', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.equals)('slice_group_map_type', 0), (0, _libConditionals.each)(function (index, output) {
  return index <= output.num_slice_groups_minus1;
}, (0, _libCombinators.data)('run_length_minus1[]', (0, _libDataTypes.ue)(v)))), (0, _libConditionals.when)((0, _libConditionals.equals)('slice_group_map_type', 2), (0, _libConditionals.each)(function (index, output) {
  return index <= output.num_slice_groups_minus1;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('top_left[]', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('bottom_right[]', (0, _libDataTypes.ue)(v))]))), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_group_map_type', [3, 4, 5]), (0, _libCombinators.list)([(0, _libCombinators.data)('slice_group_change_direction_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('slice_group_change_rate_minus1', (0, _libDataTypes.ue)(v))])), (0, _libConditionals.when)((0, _libConditionals.equals)('slice_group_map_type', 6), (0, _libCombinators.list)([(0, _libCombinators.data)('pic_size_in_map_units_minus1', (0, _libDataTypes.ue)(v)), (0, _libConditionals.each)(function (index, output) {
  return index <= output.pic_size_in_map_units_minus1;
}, (0, _libCombinators.data)('slice_group_id[]', (0, _libDataTypes.ue)(v)))]))])), (0, _libCombinators.data)('num_ref_idx_l0_default_active_minus1', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('num_ref_idx_l1_default_active_minus1', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('weighted_pred_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('weighted_bipred_idc', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('pic_init_qp_minus26', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('pic_init_qs_minus26', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_qp_index_offset', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('deblocking_filter_control_present_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constrained_intra_pred_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('redundant_pic_cnt_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.whenMoreData)((0, _libCombinators.list)([(0, _libCombinators.data)('transform_8x8_mode_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('pic_scaling_matrix_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_scaling_matrix_present_flag', 1), (0, _libConditionals.each)(function (index, output) {
  return index < 6 + (output.chroma_format_Idc !== 3 ? 2 : 6) * output.transform_8x8_mode_flag;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('pic_scaling_list_present_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_scaling_list_present_flag[]', 1), _scalingList2['default'])]))), (0, _libCombinators.data)('second_chroma_qp_index_offset', (0, _libDataTypes.se)(v))])), (0, _libCombinators.verify)('pic_parameter_set')]));

exports['default'] = ppsCodec;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"./scaling-list":8}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var scalingList = {
  decode: function decode(expGolomb, output, options, index) {
    var lastScale = 8;
    var nextScale = 8;
    var deltaScale = undefined;
    var count = 16;
    var scalingArr = [];

    if (!Array.isArray(output.scalingList)) {
      output.scalingList = [];
    }

    if (index >= 6) {
      count = 64;
    }

    for (var j = 0; j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = expGolomb.readExpGolomb();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }

      scalingArr[j] = nextScale === 0 ? lastScale : nextScale;
      lastScale = scalingArr[j];
    }

    output.scalingList[index] = scalingArr;

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {
    var lastScale = 8;
    var nextScale = 8;
    var deltaScale = undefined;
    var count = 16;
    var output = '';

    if (!Array.isArray(input.scalingList)) {
      return '';
    }

    if (index >= 6) {
      count = 64;
    }

    var scalingArr = output.scalingList[index];

    for (var j = 0; j < count; j++) {
      if (scalingArr[j] === lastScale) {
        output += expGolomb.writeExpGolomb(-lastScale);
        break;
      }
      nextScale = scalingArr[j] - lastScale;
      output += expGolomb.writeExpGolomb(nextScale);
      lastScale = scalingArr[j];
    }
    return output;
  }
};

exports['default'] = scalingList;
module.exports = exports['default'];
},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var _scalingList = require('./scaling-list');

var _scalingList2 = _interopRequireDefault(_scalingList);

var _vuiParameters = require('./vui-parameters');

var _vuiParameters2 = _interopRequireDefault(_vuiParameters);

var v = null;

var PROFILES_WITH_OPTIONAL_SPS_DATA = [44, 83, 86, 100, 110, 118, 122, 128, 134, 138, 139, 244];

var getChromaFormatIdcValue = {
  read: function read(expGolomb, output, options, index) {
    return output.chroma_format_idc || options.chroma_format_idc;
  },
  write: function write() {}
};

/**
  * NOW we are ready to build an SPS parser!
  */
var spsCodec = (0, _libCombinators.start)('seq_parameter_set', (0, _libCombinators.list)([
// defaults
(0, _libCombinators.data)('chroma_format_idc', (0, _libDataTypes.val)(1)), (0, _libCombinators.data)('video_format', (0, _libDataTypes.val)(5)), (0, _libCombinators.data)('color_primaries', (0, _libDataTypes.val)(2)), (0, _libCombinators.data)('transfer_characteristics', (0, _libDataTypes.val)(2)), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(1.0)), (0, _libCombinators.data)('profile_idc', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('constraint_set0_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set1_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set2_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set3_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set4_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set5_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set6_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('constraint_set7_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('level_idc', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('seq_parameter_set_id', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('profile_idc', PROFILES_WITH_OPTIONAL_SPS_DATA), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_format_idc', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.equals)('chroma_format_idc', 3), (0, _libCombinators.data)('separate_colour_plane_flag', (0, _libDataTypes.u)(1))), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('chroma_format_idc', 3)), (0, _libCombinators.data)('separate_colour_plane_flag', (0, _libDataTypes.val)(0))), (0, _libCombinators.data)('bit_depth_luma_minus8', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('bit_depth_chroma_minus8', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('qpprime_y_zero_transform_bypass_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('seq_scaling_matrix_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('seq_scaling_matrix_present_flag', 1), (0, _libConditionals.each)(function (index, output) {
  return index < (output.chroma_format_idc !== 3 ? 8 : 12);
}, (0, _libCombinators.list)([(0, _libCombinators.data)('seq_scaling_list_present_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('seq_scaling_list_present_flag[]', 1), _scalingList2['default'])])))])), (0, _libCombinators.data)('log2_max_frame_num_minus4', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('pic_order_cnt_type', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_order_cnt_type', 0), (0, _libCombinators.data)('log2_max_pic_order_cnt_lsb_minus4', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_order_cnt_type', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('delta_pic_order_always_zero_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('offset_for_non_ref_pic', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('offset_for_top_to_bottom_field', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('num_ref_frames_in_pic_order_cnt_cycle', (0, _libDataTypes.ue)(v)), (0, _libConditionals.each)(function (index, output) {
  return index < output.num_ref_frames_in_pic_order_cnt_cycle;
}, (0, _libCombinators.data)('offset_for_ref_frame[]', (0, _libDataTypes.se)(v)))])), (0, _libCombinators.data)('max_num_ref_frames', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('gaps_in_frame_num_value_allowed_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('pic_width_in_mbs_minus1', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('pic_height_in_map_units_minus1', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('frame_mbs_only_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('frame_mbs_only_flag', 0), (0, _libCombinators.data)('mb_adaptive_frame_field_flag', (0, _libDataTypes.u)(1))), (0, _libCombinators.data)('direct_8x8_inference_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('frame_cropping_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('frame_cropping_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('frame_crop_left_offset', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('frame_crop_right_offset', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('frame_crop_top_offset', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('frame_crop_bottom_offset', (0, _libDataTypes.ue)(v))])), (0, _libCombinators.data)('vui_parameters_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('vui_parameters_present_flag', 1), _vuiParameters2['default']),
// The following field is a derived value that is used for parsing
// slice headers
(0, _libConditionals.when)((0, _libConditionals.equals)('separate_colour_plane_flag', 1), (0, _libCombinators.data)('ChromaArrayType', (0, _libDataTypes.val)(0))), (0, _libConditionals.when)((0, _libConditionals.equals)('separate_colour_plane_flag', 0), (0, _libCombinators.data)('ChromaArrayType', getChromaFormatIdcValue)), (0, _libCombinators.verify)('seq_parameter_set')]));

exports['default'] = spsCodec;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"./scaling-list":8,"./vui-parameters":13}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var v = null;

var sliceType = {
  P: [0, 5],
  B: [1, 6],
  I: [2, 7],
  SP: [3, 8],
  SI: [4, 9]
};

/**
 * Functions for calculating the number of bits to read for certain
 * properties based on the values in other properties (usually specified
 * in the SPS)
 */
var frameNumBits = function frameNumBits(expGolomb, data, options, index) {
  return options.log2_max_frame_num_minus4 + 4;
};

var picOrderCntBits = function picOrderCntBits(expGolomb, data, options, index) {
  return options.log2_max_pic_order_cnt_lsb_minus4 + 4;
};

var sliceGroupChangeCycleBits = function sliceGroupChangeCycleBits(expGolomb, data, options, index) {
  var picHeightInMapUnits = options.pic_height_in_map_units_minus1 + 1;
  var picWidthInMbs = options.pic_width_in_mbs_minus1 + 1;
  var sliceGroupChangeRate = options.slice_group_change_rate_minus1 + 1;
  var picSizeInMapUnits = picWidthInMbs * picHeightInMapUnits;

  return Math.ceil(Math.log(picSizeInMapUnits / sliceGroupChangeRate + 1) / Math.LN2);
};

var useWeightedPredictionTable = (0, _libConditionals.some)([(0, _libConditionals.every)([(0, _libConditionals.equals)('weighted_pred_flag', 1), (0, _libConditionals.some)([(0, _libConditionals.inArray)('slice_type', sliceType.P), (0, _libConditionals.inArray)('slice_type', sliceType.SP)])]), (0, _libConditionals.every)([(0, _libConditionals.equals)('weighted_bipred_idc', 1), (0, _libConditionals.inArray)('slice_type', sliceType.B)])]);

var refPicListModification = (0, _libCombinators.list)([(0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.not)((0, _libConditionals.inArray)('slice_type', sliceType.I)), (0, _libConditionals.not)((0, _libConditionals.inArray)('slice_type', sliceType.SI))]), (0, _libCombinators.list)([(0, _libCombinators.data)('ref_pic_list_modification_flag_l0', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('ref_pic_list_modification_flag_l0', 1), (0, _libConditionals.each)(function (index, output) {
  return index === 0 || output.modification_of_pic_nums_idc_l0[index - 1] !== 3;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('modification_of_pic_nums_idc_l0[]', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('modification_of_pic_nums_idc_l0[]', [0, 1]), (0, _libCombinators.data)('abs_diff_pic_num_minus1_l0[]', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.equals)('modification_of_pic_nums_idc_l0[]', 2), (0, _libCombinators.data)('long_term_pic_num_l0[]', (0, _libDataTypes.ue)(v)))])))])), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_type', sliceType.B), (0, _libCombinators.list)([(0, _libCombinators.data)('ref_pic_list_modification_flag_l1', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('ref_pic_list_modification_flag_l1', 1), (0, _libConditionals.each)(function (index, output) {
  return index === 0 || output.modification_of_pic_nums_idc_l1[index - 1] !== 3;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('modification_of_pic_nums_idc_l1[]', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('modification_of_pic_nums_idc_l1[]', [0, 1]), (0, _libCombinators.data)('abs_diff_pic_num_minus1_l1[]', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.equals)('modification_of_pic_nums_idc_l1[]', 2), (0, _libCombinators.data)('long_term_pic_num_l1[]', (0, _libDataTypes.ue)(v)))])))]))]);

var refPicListMvcModification = {
  encode: function encode() {
    throw new Error('ref_pic_list_mvc_modification: NOT IMPLEMENTED!');
  },
  decode: function decode() {
    throw new Error('ref_pic_list_mvc_modification: NOT IMPLEMENTED!');
  }
};

var predWeightTable = (0, _libCombinators.list)([(0, _libCombinators.data)('luma_log2_weight_denom', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('ChromaArrayType', 0)), (0, _libCombinators.data)('chroma_log2_weight_denom', (0, _libDataTypes.ue)(v))), (0, _libConditionals.each)(function (index, output) {
  return index <= output.num_ref_idx_l0_active_minus1;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('luma_weight_l0_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('luma_weight_l0_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('luma_weight_l0[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('luma_offset_l0[]', (0, _libDataTypes.se)(v)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('ChromaArrayType', 0)), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_weight_l0_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('chroma_weight_l0_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_weight_l0_Cr[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_offset_l0_Cr[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_weight_l0_Cb[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_offset_l0_Cb[]', (0, _libDataTypes.se)(v))]))]))]))])), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_type', sliceType.B), (0, _libConditionals.each)(function (index, output) {
  return index <= output.num_ref_idx_l1_active_minus1;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('luma_weight_l1_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('luma_weight_l1_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('luma_weight_l1[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('luma_offset_l1[]', (0, _libDataTypes.se)(v)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('ChromaArrayType', 0)), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_weight_l1_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('chroma_weight_l1_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_weight_l1_Cr[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_offset_l1_Cr[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_weight_l1_Cb[]', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('chroma_offset_l1_Cb[]', (0, _libDataTypes.se)(v))]))]))]))])))]);

var decRefPicMarking = (0, _libCombinators.list)([(0, _libConditionals.when)((0, _libConditionals.equals)('nal_unit_type', 5), (0, _libCombinators.list)([(0, _libCombinators.data)('no_output_of_prior_pics_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('long_term_reference_flag', (0, _libDataTypes.u)(1))])), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('nal_unit_type', 5)), (0, _libCombinators.list)([(0, _libCombinators.data)('adaptive_ref_pic_marking_mode_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('adaptive_ref_pic_marking_mode_flag', 1), (0, _libConditionals.each)(function (index, output) {
  return index === 0 || output.memory_management_control_operation[index - 1] !== 0;
}, (0, _libCombinators.list)([(0, _libCombinators.data)('memory_management_control_operation[]', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('memory_management_control_operation[]', [1, 3]), (0, _libCombinators.data)('difference_of_pic_nums_minus1[]', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.inArray)('memory_management_control_operation[]', [2]), (0, _libCombinators.data)('long_term_pic_num[]', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.inArray)('memory_management_control_operation[]', [3, 6]), (0, _libCombinators.data)('long_term_frame_idx[]', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.inArray)('memory_management_control_operation[]', [4]), (0, _libCombinators.data)('max_long_term_frame_idx_plus1[]', (0, _libDataTypes.ue)(v)))])))]))]);

var sliceHeader = (0, _libCombinators.list)([(0, _libCombinators.data)('first_mb_in_slice', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('slice_type', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('pic_parameter_set_id', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.equals)('separate_colour_plane_flag', 1), (0, _libCombinators.data)('colour_plane_id', (0, _libDataTypes.u)(2))), (0, _libCombinators.data)('frame_num', (0, _libDataTypes.u)(frameNumBits)), (0, _libConditionals.when)((0, _libConditionals.equals)('frame_mbs_only_flag', 0), (0, _libCombinators.list)([(0, _libCombinators.data)('field_pic_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('field_pic_flag', 1), (0, _libCombinators.data)('bottom_field_flag', (0, _libDataTypes.u)(1)))])), (0, _libConditionals.when)((0, _libConditionals.equals)('idrPicFlag', 1), (0, _libCombinators.data)('idr_pic_id', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_order_cnt_type', 0), (0, _libCombinators.list)([(0, _libCombinators.data)('pic_order_cnt_lsb', (0, _libDataTypes.u)(picOrderCntBits)), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.equals)('bottom_field_pic_order_in_frame_present_flag', 1), (0, _libConditionals.not)((0, _libConditionals.equals)('field_pic_flag', 1))]), (0, _libCombinators.data)('delta_pic_order_cnt_bottom', (0, _libDataTypes.se)(v)))])), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.equals)('pic_order_cnt_type', 1), (0, _libConditionals.not)((0, _libConditionals.equals)('delta_pic_order_always_zero_flag', 1))]), (0, _libCombinators.list)([(0, _libCombinators.data)('delta_pic_order_cnt[0]', (0, _libDataTypes.se)(v)), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.equals)('bottom_field_pic_order_in_frame_present_flag', 1), (0, _libConditionals.not)((0, _libConditionals.equals)('field_pic_flag', 1))]), (0, _libCombinators.data)('delta_pic_order_cnt[1]', (0, _libDataTypes.se)(v)))])), (0, _libConditionals.when)((0, _libConditionals.equals)('redundant_pic_cnt_present_flag', 1), (0, _libCombinators.data)('redundant_pic_cnt', (0, _libDataTypes.ue)(v))), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_type', sliceType.B), (0, _libCombinators.data)('direct_spatial_mv_pred_flag', (0, _libDataTypes.u)(1))), (0, _libConditionals.when)((0, _libConditionals.some)([(0, _libConditionals.inArray)('slice_type', sliceType.P), (0, _libConditionals.inArray)('slice_type', sliceType.SP), (0, _libConditionals.inArray)('slice_type', sliceType.B)]), (0, _libCombinators.list)([(0, _libCombinators.data)('num_ref_idx_active_override_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('num_ref_idx_active_override_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('num_ref_idx_l0_active_minus1', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_type', sliceType.B), (0, _libCombinators.data)('num_ref_idx_l1_active_minus1', (0, _libDataTypes.ue)(v)))]))])), (0, _libConditionals.when)((0, _libConditionals.some)([(0, _libConditionals.equals)('nal_unit_type', 20), (0, _libConditionals.equals)('nal_unit_type', 21)]), refPicListMvcModification), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.not)((0, _libConditionals.equals)('nal_unit_type', 20)), (0, _libConditionals.not)((0, _libConditionals.equals)('nal_unit_type', 21))]), refPicListModification), (0, _libConditionals.when)(useWeightedPredictionTable, predWeightTable), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('nal_ref_idc', 0)), decRefPicMarking), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.equals)('entropy_coding_mode_flag', 1), (0, _libConditionals.not)((0, _libConditionals.inArray)('slice_type', sliceType.I)), (0, _libConditionals.not)((0, _libConditionals.inArray)('slice_type', sliceType.SI))]), (0, _libCombinators.data)('cabac_init_idc', (0, _libDataTypes.ue)(v))), (0, _libCombinators.data)('slice_qp_delta', (0, _libDataTypes.se)(v)), (0, _libConditionals.when)((0, _libConditionals.inArray)('slice_type', sliceType.SP), (0, _libCombinators.data)('sp_for_switch_flag', (0, _libDataTypes.u)(1))), (0, _libConditionals.when)((0, _libConditionals.some)([(0, _libConditionals.inArray)('slice_type', sliceType.SP), (0, _libConditionals.inArray)('slice_type', sliceType.SI)]), (0, _libCombinators.data)('slice_qs_delta', (0, _libDataTypes.se)(v))), (0, _libConditionals.when)((0, _libConditionals.equals)('deblocking_filter_control_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('disable_deblocking_filter_idc', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.not)((0, _libConditionals.equals)('disable_deblocking_filter_idc', 1)), (0, _libCombinators.list)([(0, _libCombinators.data)('slice_alpha_c0_offset_div2', (0, _libDataTypes.se)(v)), (0, _libCombinators.data)('slice_beta_offset_div2', (0, _libDataTypes.se)(v))]))])), (0, _libConditionals.when)((0, _libConditionals.every)([(0, _libConditionals.not)((0, _libConditionals.equals)('num_slice_groups_minus1', 0)), (0, _libConditionals.some)([(0, _libConditionals.equals)('slice_group_map_type', 3), (0, _libConditionals.equals)('slice_group_map_type', 4), (0, _libConditionals.equals)('slice_group_map_type', 5)])]), (0, _libCombinators.data)('slice_group_change_cycle', (0, _libDataTypes.u)(sliceGroupChangeCycleBits)))]);

exports['default'] = sliceHeader;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _sliceHeader = require('./slice-header');

var _sliceHeader2 = _interopRequireDefault(_sliceHeader);

var _libCombinators = require('../../lib/combinators');

var sliceLayerWithoutPartitioningCodec = (0, _libCombinators.start)('slice_layer_without_partitioning', (0, _libCombinators.list)([_sliceHeader2['default']
// TODO: slice_data
]));

exports['default'] = sliceLayerWithoutPartitioningCodec;
module.exports = exports['default'];
},{"../../lib/combinators":21,"./slice-header":10}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _libExpGolombString = require('../../lib/exp-golomb-string');

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var _libRbspUtils = require('../../lib/rbsp-utils');

var v = null;

var noopCodec = (0, _libCombinators.list)([]);

var initialCpbRemovalDelayLength = function initialCpbRemovalDelayLength(expGolomb, data, options, index) {
  return options.initial_cpb_removal_delay_length_minus1 + 1;
};

var cpbRemovalDelayBits = function cpbRemovalDelayBits(expGolomb, data, options, index) {
  return options.cpb_removal_delay_length_minus1 + 1;
};

var dpbOutputDelayBits = function dpbOutputDelayBits(expGolomb, data, options, index) {
  return options.dpb_output_delay_length_minus1 + 1;
};

var timeOffsetBits = function timeOffsetBits(expGolomb, data, options, index) {
  return options.time_offset_length;
};

var seiPayloadCodecs = {
  '0': {
    name: 'buffering_period',
    codec: (0, _libCombinators.list)([(0, _libCombinators.data)('seq_parameter_set_id', (0, _libDataTypes.ue)(v)), (0, _libConditionals.when)((0, _libConditionals.equals)('nal_hrd_parameters_present_flag', 1), (0, _libConditionals.each)(function (index, output, options) {
      return index <= options.cpb_cnt_minus1;
    }, (0, _libCombinators.list)([(0, _libCombinators.data)('initial_cpb_removal_delay[]', (0, _libDataTypes.u)(initialCpbRemovalDelayLength)), (0, _libCombinators.data)('initial_cpb_removal_delay_offset[]', (0, _libDataTypes.u)(initialCpbRemovalDelayLength))]))), (0, _libConditionals.when)((0, _libConditionals.equals)('vcl_hrd_parameters_present_flag', 1), (0, _libConditionals.each)(function (index, output, options) {
      return index <= options.cpb_cnt_minus1;
    }, (0, _libCombinators.list)([(0, _libCombinators.data)('initial_cpb_removal_delay[]', (0, _libDataTypes.u)(initialCpbRemovalDelayLength)), (0, _libCombinators.data)('initial_cpb_removal_delay_offset[]', (0, _libDataTypes.u)(initialCpbRemovalDelayLength))])))])
  },
  '1': {
    name: 'pic_timing',
    codec: (0, _libCombinators.list)([(0, _libConditionals.when)((0, _libConditionals.some)([(0, _libConditionals.equals)('nal_hrd_parameters_present_flag', 1), (0, _libConditionals.equals)('vcl_hrd_parameters_present_flag', 1)]), (0, _libCombinators.list)([(0, _libCombinators.data)('cpb_removal_delay', (0, _libDataTypes.u)(cpbRemovalDelayBits)), (0, _libCombinators.data)('dpb_output_delay', (0, _libDataTypes.u)(dpbOutputDelayBits))])), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('pic_struct', (0, _libDataTypes.u)(4)),

    // Interpret pic_struct
    (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 0), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(1))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 1), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(1))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 2), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(1))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 3), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(2))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 4), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(2))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 5), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(3))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 6), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(3))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 7), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(2))), (0, _libConditionals.when)((0, _libConditionals.equals)('pic_struct', 8), (0, _libCombinators.data)('NumClockTS', (0, _libDataTypes.val)(2))), (0, _libConditionals.each)(function (index, output) {
      return index < output.NumClockTS;
    }, (0, _libCombinators.list)([(0, _libCombinators.data)('clock_timestamp_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('clock_timestamp_flag[]', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('ct_type[]', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('nuit_field_based_flag[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('counting_type[]', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('full_timestamp_flag[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('discontinuity_flag[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('cnt_dropped_flag[]', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('n_frames[]', (0, _libDataTypes.u)(8)), (0, _libConditionals.when)((0, _libConditionals.equals)('full_timestamp_flag[]', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('seconds_value[]', (0, _libDataTypes.u)(6)), (0, _libCombinators.data)('minutes_value[]', (0, _libDataTypes.u)(6)), (0, _libCombinators.data)('hours_value[]', (0, _libDataTypes.u)(5))])), (0, _libConditionals.when)((0, _libConditionals.equals)('full_timestamp_flag[]', 0), (0, _libCombinators.list)([(0, _libCombinators.data)('seconds_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('seconds_flag[]', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('seconds_value[]', (0, _libDataTypes.u)(6)), (0, _libCombinators.data)('minutes_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('minutes_flag[]', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('minutes_value[]', (0, _libDataTypes.u)(6)), (0, _libCombinators.data)('hours_flag[]', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('hours_flag[]', 1), (0, _libCombinators.data)('hours_value[]', (0, _libDataTypes.u)(5)))]))]))])), (0, _libConditionals.when)((0, _libConditionals.gt)('time_offset_length', 0), (0, _libCombinators.data)('time_offset', (0, _libDataTypes.u)(timeOffsetBits)))]))]))]))])
  },
  '2': {
    name: 'pan_scan_rect'
  },
  '3': {
    name: 'filler_payload'
  },
  '4': {
    name: 'user_data_registered_itu_t_t35',
    codec: (0, _libCombinators.list)([(0, _libCombinators.data)('itu_t_t35_country_code', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('itu_t_t35_provider_code', (0, _libDataTypes.u)(16)), (0, _libConditionals.when)((0, _libConditionals.equals)('itu_t_t35_provider_code', 49), (0, _libCombinators.data)('ATSC_user_identifier', (0, _libDataTypes.u)(32))), (0, _libConditionals.when)((0, _libConditionals.inArray)('itu_t_t35_provider_code', [47, 49]), (0, _libCombinators.data)('ATSC1_data_user_data_type_code', (0, _libDataTypes.u)(8))), (0, _libConditionals.when)((0, _libConditionals.equals)('itu_t_t35_provider_code', 47), (0, _libCombinators.data)('DIRECTV_user_data_length', (0, _libDataTypes.u)(8))), (0, _libCombinators.data)('process_em_data_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('process_cc_data_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('additional_data_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('cc_count', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('em_data', (0, _libDataTypes.u)(8)), (0, _libConditionals.each)(function (index, output) {
      return index < output.cc_count;
    }, (0, _libCombinators.newObj)('cc_data_pkts[]', (0, _libCombinators.list)([(0, _libCombinators.data)('type', (0, _libDataTypes.val)('cc_data_pkt')), (0, _libCombinators.data)('marker_bits', (0, _libDataTypes.u)(5)), (0, _libCombinators.data)('cc_valid', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('cc_type', (0, _libDataTypes.u)(2)), (0, _libCombinators.data)('cc_data_1', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('cc_data_2', (0, _libDataTypes.u)(8))]))), (0, _libCombinators.data)('marker_bits', (0, _libDataTypes.u)(8))])
  },
  '5': {
    name: 'user_data_unregistered'
  },
  '6': {
    name: 'recovery_point',
    codec: (0, _libCombinators.list)([(0, _libCombinators.data)('recovery_frame_cnt', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('exact_match_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('broken_link_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('changing_slice_group_idc', (0, _libDataTypes.u)(2))])
  },
  '7': {
    name: 'dec_ref_pic_marking_repetition'
  },
  '8': {
    name: 'spare_pic'
  },
  '9': {
    name: 'scene_info'
  },
  '10': {
    name: 'sub_seq_info'
  },
  '11': {
    name: 'sub_seq_layer_characteristics'
  },
  '12': {
    name: 'sub_seq_characteristics'
  },
  '13': {
    name: 'full_frame_freeze'
  },
  '14': {
    name: 'full_frame_freeze_release'
  },
  '15': {
    name: 'full_frame_snapshot'
  },
  '16': {
    name: 'progressive_refinement_segment_start'
  },
  '17': {
    name: 'progressive_refinement_segment_end'
  },
  '18': {
    name: 'motion_constrained_slice_group_set'
  },
  '19': {
    name: 'film_grain_characteristics'
  },
  '20': {
    name: 'deblocking_filter_display_preference'
  },
  '21': {
    name: 'stereo_video_info'
  },
  '22': {
    name: 'post_filter_hint'
  },
  '23': {
    name: 'tone_mapping_info'
  },
  '24': {
    name: 'scalability_info'
  },
  '25': {
    name: 'sub_pic_scalable_layer'
  },
  '26': {
    name: 'non_required_layer_rep'
  },
  '27': {
    name: 'priority_layer_info'
  },
  '28': {
    name: 'layers_not_present'
  },
  '29': {
    name: 'layer_dependency_change'
  },
  '30': {
    name: 'scalable_nesting'
  },
  '31': {
    name: 'base_layer_temporal_hrd'
  },
  '32': {
    name: 'quality_layer_integrity_check'
  },
  '33': {
    name: 'redundant_pic_property'
  },
  '34': {
    name: 'tl'
  },
  '35': {
    name: 'tl_switching_point'
  },
  '36': {
    name: 'parallel_decoding_info'
  },
  '37': {
    name: 'mvc_scalable_nesting'
  },
  '38': {
    name: 'view_scalability_info'
  },
  '39': {
    name: 'multiview_scene_info'
  },
  '40': {
    name: 'multiview_acquisition_info'
  },
  '41': {
    name: 'non_required_view_component'
  },
  '42': {
    name: 'view_dependency_change'
  },
  '43': {
    name: 'operation_points_not_present'
  },
  '44': {
    name: 'base_view_temporal_hrd'
  },
  '45': {
    name: 'frame_packing_arrangement'
  }
};

var seiPayloadParser = {
  decode: function decode(expGolomb, output, options, index) {
    var message = {
      payloadType: 0,
      payloadSize: 0
    };

    var payloadByte = undefined;

    do {
      payloadByte = expGolomb.readUnsignedByte();
      message.payloadType += payloadByte;
    } while (payloadByte === 255);

    do {
      payloadByte = expGolomb.readUnsignedByte();
      message.payloadSize += payloadByte;
    } while (payloadByte === 255);

    var payloadCodec = seiPayloadCodecs[message.payloadType];
    var bitString = expGolomb.readRawBits(message.payloadSize * 8);

    if (payloadCodec) {
      message.type = payloadCodec.name;

      if (payloadCodec.codec) {
        var subExpGolomb = new _libExpGolombString.ExpGolombDecoder(bitString);
        payloadCodec.codec.decode(subExpGolomb, message, options);
      } else {
        message.data = (0, _libRbspUtils.bitStringToTypedArray)(bitString);
      }
    } else {
      message.type = 'unknown type';
      message.data = (0, _libRbspUtils.bitStringToTypedArray)(bitString);
    }

    output[index] = message;

    return output;
  },
  encode: function encode(expGolomb, input, options, index) {
    // This function was never tested...
    var message = input[index];
    var payloadTypeRemaining = message.payloadType;

    while (payloadTypeRemaining > 255) {
      payloadTypeRemaining -= 255;
      expGolomb.writeUnsignedByte(255);
    }
    expGolomb.writeUnsignedByte(payloadTypeRemaining);

    var payloadSizeRemaining = message.payloadSize;

    while (payloadSizeRemaining > 255) {
      payloadSizeRemaining -= 255;
      expGolomb.writeUnsignedByte(255);
    }
    expGolomb.writeUnsignedByte(payloadSizeRemaining);

    var payloadCodec = seiPayloadCodecs[message.payloadType];

    if (payloadCodec && payloadCodec.codec) {
      var subExpGolomb = new _libExpGolombString.ExpGolombEncoder();
      payloadCodec.codec.encode(subExpGolomb, message, options);
      var bits = subExpGolomb.bitReservoir;

      if (bits.length % 8 !== 0) {
        bits = (0, _libRbspUtils.appendRBSPTrailingBits)(bits);
      }

      expGolomb.writeRawBits(message.payloadSize * 8, bits);
    } else if (message.data) {
      expGolomb.writeRawBits(message.payloadSize * 8, (0, _libRbspUtils.typedArrayToBitString)(message.data));
    } else {
      // worse case scenario, just write 0s
      expGolomb.writeRawBits(message.payloadSize * 8, '');
    }
  }
};

/**
  * NOW we are ready to build an sei-message parser!
  */

var seiCodec = (0, _libCombinators.startArray)('sei_message', (0, _libConditionals.whileMoreData)(seiPayloadParser));

exports['default'] = seiCodec;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"../../lib/exp-golomb-string":25,"../../lib/rbsp-utils":27}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libCombinators = require('../../lib/combinators');

var _libConditionals = require('../../lib/conditionals');

var _libDataTypes = require('../../lib/data-types');

var _hdrParameters = require('./hdr-parameters');

var _hdrParameters2 = _interopRequireDefault(_hdrParameters);

var v = null;

var sampleRatioCalc = (0, _libCombinators.list)([
/*
  1:1
 7680x4320 16:9 frame without horizontal overscan
 3840x2160 16:9 frame without horizontal overscan
 1280x720 16:9 frame without horizontal overscan
 1920x1080 16:9 frame without horizontal overscan (cropped from 1920x1088)
 640x480 4:3 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 1), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(1))),
/*
  12:11
 720x576 4:3 frame with horizontal overscan
 352x288 4:3 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 2), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(12 / 11))),
/*
  10:11
 720x480 4:3 frame with horizontal overscan
 352x240 4:3 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 3), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(10 / 11))),
/*
  16:11
 720x576 16:9 frame with horizontal overscan
 528x576 4:3 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 4), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(16 / 11))),
/*
  40:33
 720x480 16:9 frame with horizontal overscan
 528x480 4:3 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 5), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(40 / 33))),
/*
  24:11
 352x576 4:3 frame without horizontal overscan
 480x576 16:9 frame with horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 6), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(24 / 11))),
/*
  20:11
 352x480 4:3 frame without horizontal overscan
 480x480 16:9 frame with horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 7), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(20 / 11))),
/*
  32:11
 352x576 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 8), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(32 / 11))),
/*
  80:33
 352x480 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 9), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(80 / 33))),
/*
  18:11
 480x576 4:3 frame with horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 10), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(18 / 11))),
/*
  15:11
 480x480 4:3 frame with horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 11), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(15 / 11))),
/*
  64:33
 528x576 16:9 frame with horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 12), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(64 / 33))),
/*
  160:99
 528x480 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 13), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(160 / 99))),
/*
  4:3
 1440x1080 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 14), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(4 / 3))),
/*
  3:2
 1280x1080 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 15), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(3 / 2))),
/*
  2:1
 960x1080 16:9 frame without horizontal overscan
 */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 16), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(2 / 1))),
/* Extended_SAR */
(0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_idc', 255), (0, _libCombinators.list)([(0, _libCombinators.data)('sar_width', (0, _libDataTypes.u)(16)), (0, _libCombinators.data)('sar_height', (0, _libDataTypes.u)(16)), (0, _libCombinators.data)('sample_ratio', (0, _libDataTypes.val)(function (expGolomb, output, options) {
  return output.sar_width / output.sar_height;
}))]))]);

var vuiParamters = (0, _libCombinators.list)([(0, _libCombinators.data)('aspect_ratio_info_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('aspect_ratio_info_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('aspect_ratio_idc', (0, _libDataTypes.u)(8)), sampleRatioCalc])), (0, _libCombinators.data)('overscan_info_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('overscan_info_present_flag', 1), (0, _libCombinators.data)('overscan_appropriate_flag', (0, _libDataTypes.u)(1))), (0, _libCombinators.data)('video_signal_type_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('video_signal_type_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('video_format', (0, _libDataTypes.u)(3)), (0, _libCombinators.data)('video_full_range_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('colour_description_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('colour_description_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('colour_primaries', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('transfer_characteristics', (0, _libDataTypes.u)(8)), (0, _libCombinators.data)('matrix_coefficients', (0, _libDataTypes.u)(8))]))])), (0, _libCombinators.data)('chroma_loc_info_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('chroma_loc_info_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('chroma_sample_loc_type_top_field', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('chroma_sample_loc_type_bottom_field', (0, _libDataTypes.ue)(v))])), (0, _libCombinators.data)('timing_info_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('timing_info_present_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('num_units_in_tick', (0, _libDataTypes.u)(32)), (0, _libCombinators.data)('time_scale', (0, _libDataTypes.u)(32)), (0, _libCombinators.data)('fixed_frame_rate_flag', (0, _libDataTypes.u)(1))])), (0, _libCombinators.data)('nal_hrd_parameters_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('nal_hrd_parameters_present_flag', 1), _hdrParameters2['default']), (0, _libCombinators.data)('vcl_hrd_parameters_present_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('vcl_hrd_parameters_present_flag', 1), _hdrParameters2['default']), (0, _libConditionals.when)((0, _libConditionals.some)([(0, _libConditionals.equals)('nal_hrd_parameters_present_flag', 1), (0, _libConditionals.equals)('vcl_hrd_parameters_present_flag', 1)]), (0, _libCombinators.data)('low_delay_hrd_flag', (0, _libDataTypes.u)(1))), (0, _libCombinators.data)('pic_struct_present_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('bitstream_restriction_flag', (0, _libDataTypes.u)(1)), (0, _libConditionals.when)((0, _libConditionals.equals)('bitstream_restriction_flag', 1), (0, _libCombinators.list)([(0, _libCombinators.data)('motion_vectors_over_pic_boundaries_flag', (0, _libDataTypes.u)(1)), (0, _libCombinators.data)('max_bytes_per_pic_denom', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('max_bits_per_mb_denom', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('log2_max_mv_length_horizontal', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('log2_max_mv_length_vertical', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('max_num_reorder_frames', (0, _libDataTypes.ue)(v)), (0, _libCombinators.data)('max_dec_frame_buffering', (0, _libDataTypes.ue)(v))]))]);

exports['default'] = vuiParamters;
module.exports = exports['default'];
},{"../../lib/combinators":21,"../../lib/conditionals":22,"../../lib/data-types":23,"./hdr-parameters":5}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _bitStreamsAacRaw_bit_stream = require('../../bit-streams/aac/raw_bit_stream');

var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];

var parseAac = function parseAac(buffer) {
  return aacBitStream.decode(buffer, {}, []);
};

exports.parseAac = parseAac;
var parseAdts = function parseAdts(packet) {
  var result = [];
  var offset = 0;
  var frameNum = 0;
  var buffer = packet.data;

  while (offset < buffer.length) {
    // Loook for the start of an ADTS header
    if (buffer[offset] !== 0xFF || (buffer[offset + 1] & 0xF6) !== 0xF0) {
      // If a valid header was not found,  jump one forward and attempt to
      // find a valid ADTS header starting at the next byte
      offset++;
      continue;
    }

    var id = (buffer[offset + 1] & 0x08) >> 3;
    var layer = (buffer[offset + 1] & 0x06) >> 1;
    // The protection skip bit tells us if we have 2 bytes of CRC data at the
    // end of the ADTS header
    var protectionAbsent = buffer[offset + 1] & 0x01;
    var profile = (buffer[offset + 2] >>> 6 & 0x03) + 1;
    var samplingFrequencyIndex = (buffer[offset + 2] & 0x3c) >>> 2;
    var channelConfiguration = (buffer[offset + 2] & 1) << 2 | (buffer[offset + 3] & 0xc0) >>> 6;
    // Frame length is a 13 bit integer starting 16 bits from the
    // end of the sync sequence
    var aacFrameLength = (buffer[offset + 3] & 0x03) << 11 | buffer[offset + 4] << 3 | (buffer[offset + 5] & 0xe0) >> 5;
    var adtsBufferFullness = (buffer[offset + 5] & 31) << 5 | (buffer[offset + 6] & 63 << 2) >> 2;
    var numberOfRawDataBlocksInFrame = buffer[offset + 6] & 0x3;

    // Derived values
    var samplingRate = ADTS_SAMPLING_FREQUENCIES[samplingFrequencyIndex];
    var protectionSkipBytes = protectionAbsent ? 0 : 2;
    var sampleCount = ((buffer[offset + 6] & 0x03) + 1) * 1024;
    var adtsFrameDuration = sampleCount * 90000 / samplingRate;
    var frameEnd = offset + aacFrameLength;

    var data = buffer.subarray(offset + 7 + protectionSkipBytes, frameEnd);
    // Otherwise, deliver the complete AAC frame
    var adtsFrame = {
      type: 'frame',
      pts: packet.pts + frameNum * adtsFrameDuration,
      dts: packet.dts + frameNum * adtsFrameDuration,
      ID: id,
      layer: layer,
      sample_count: sampleCount,
      protection_absent: protectionAbsent,
      profile: profile,
      channel_configuration: channelConfiguration,
      sampling_rate: samplingRate,
      sampling_frequency_index: samplingFrequencyIndex,
      aac_frame_length: aacFrameLength,
      adts_buffer_fullness: adtsBufferFullness,
      number_of_raw_data_blocks_in_frame: numberOfRawDataBlocksInFrame,
      data: data
    };
    var options = {
      no_trailer_bits: true,
      sampling_frequency_index: adtsFrame.sampling_frequency_index
    };

    adtsFrame.elements = _bitStreamsAacRaw_bit_stream.aacCodec.decode(adtsFrame.data, options);
    result.push(adtsFrame);

    offset = frameEnd;
    frameNum++;
  }

  return result;
};
exports.parseAdts = parseAdts;
},{"../../bit-streams/aac/raw_bit_stream":2}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var dataToHex = function dataToHex(value, indent) {
  var bytesAsArray = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
  // print out raw bytes as hexademical
  var ascii = bytesAsArray.reduce(groupBy(16), []).map(function (line) {
    return line.map(function (byte) {
      return byte <= 31 || byte >= 127 && byte <= 159 ? '.' : String.fromCharCode(byte);
    }).map(function (char) {
      return char === '&' ? '&amp;' : char === '<' ? '&lt;' : char;
    });
  }).map(function (a) {
    return a.join('');
  });
  /*      .join('')
        .match(/.{1,48}/g);*/

  var bytes = bytesAsArray.map(function (byte) {
    return ('00' + byte.toString(16)).slice(-2);
  }).reduce(groupBy(8), []) // form arrays of 8-bytes each
  .reduce(groupBy(2), []) // create arrays of pairs of 8-byte arrays
  .map(function (a) {
    return a.map(function (a) {
      return a.join(' ');
    }).join('  ');
  }); // Stringify
  /*      .join('')
        .match(/.{1,48}/g);*/

  if (!bytes) {
    return '<>';
  }

  return bytes.map(function (line, index) {
    var hexSide = indent + line;

    // Pad so that the remaining line length is 70 (= 48 + 6 + 16) for hex, pad, ascii
    while (hexSide.length < 54) hexSide += ' ';

    return hexSide + ascii[index];
  }).join('\n');
};

var groupBy = function groupBy(count) {
  return function (p, c) {
    var last = p.pop();

    if (!last) {
      last = [];
    } else if (last.length === count) {
      p.push(last);
      last = [];
    }
    last.push(c);
    p.push(last);
    return p;
  };
};

exports['default'] = dataToHex;
module.exports = exports['default'];
},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _bitStreamsH264 = require('../../bit-streams/h264');

var lastSPS = undefined;
var lastPPS = undefined;
var lastOptions = undefined;

var mergePS = function mergePS(a, b) {
  var newObj = {};

  if (a) {
    Object.keys(a).forEach(function (key) {
      newObj[key] = a[key];
    });
  }

  if (b) {
    Object.keys(b).forEach(function (key) {
      newObj[key] = b[key];
    });
  }

  return newObj;
};

exports.mergePS = mergePS;
var nalParseAVCC = function nalParseAVCC(avcStream) {
  var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),
      result = [],
      nalData,
      i,
      length;

  for (i = 0; i + 4 < avcStream.length; i += length) {
    length = avcView.getUint32(i);
    i += 4;

    // bail if this doesn't appear to be an H264 stream
    if (length <= 0) {
      result.push({
        type: 'MALFORMED-DATA'
      });
      continue;
    }
    if (length > avcStream.length) {
      result.push({
        type: 'UNKNOWN MDAT DATA'
      });
      return;
    }

    var nalUnit = avcStream.subarray(i, i + length);

    result.push(nalParse(nalUnit));
  }

  return result;
};

exports.nalParseAVCC = nalParseAVCC;
var nalParseAnnexB = function nalParseAnnexB(buffer) {
  var syncPoint = 0;
  var i = undefined;
  var result = [];

  // Rec. ITU-T H.264, Annex B
  // scan for NAL unit boundaries

  // a match looks like this:
  // 0 0 1 .. NAL .. 0 0 1
  // ^ sync point        ^ i
  // or this:
  // 0 0 1 .. NAL .. 0 0 0
  // ^ sync point        ^ i

  // advance the sync point to a NAL start, if necessary
  for (; syncPoint < buffer.byteLength - 3; syncPoint++) {
    if (buffer[syncPoint] === 0 && buffer[syncPoint + 1] === 0 && buffer[syncPoint + 2] === 1) {
      // the sync point is properly aligned
      i = syncPoint + 5;
      break;
    }
  }

  while (i < buffer.byteLength) {
    if (syncPoint === undefined) {
      debugger;
    }
    // look at the current byte to determine if we've hit the end of
    // a NAL unit boundary
    switch (buffer[i]) {
      case 0:
        // skip past non-sync sequences
        if (buffer[i - 1] !== 0) {
          i += 2;
          break;
        } else if (buffer[i - 2] !== 0) {
          i++;
          break;
        }

        // deliver the NAL unit if it isn't empty
        if (syncPoint + 3 !== i - 2) {
          result.push(nalParse(buffer.subarray(syncPoint + 3, i - 2)));
        }

        // drop trailing zeroes
        do {
          i++;
        } while (buffer[i] !== 1 && i < buffer.length);
        syncPoint = i - 2;
        i += 3;
        break;
      case 1:
        // skip past non-sync sequences
        if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
          i += 3;
          break;
        }

        // deliver the NAL unit
        result.push(nalParse(buffer.subarray(syncPoint + 3, i - 2)));
        syncPoint = i - 2;
        i += 3;
        break;
      default:
        // the current byte isn't a one or zero, so it cannot be part
        // of a sync sequence
        i += 3;
        break;
    }
  }
  // filter out the NAL units that were delivered
  buffer = buffer.subarray(syncPoint);
  i -= syncPoint;
  syncPoint = 0;

  // deliver the last buffered NAL unit
  if (buffer && buffer.byteLength > 3) {
    result.push(nalParse(buffer.subarray(syncPoint + 3)));
  }

  return result;
};

exports.nalParseAnnexB = nalParseAnnexB;
var nalParse = function nalParse(nalUnit) {
  var nalData = undefined;

  if (nalUnit.length > 1) {
    nalData = (0, _bitStreamsH264.discardEmulationPrevention)(nalUnit.subarray(1));
  } else {
    nalData = nalUnit;
  }

  var nalUnitType = nalUnit[0] & 0x1F;
  var nalRefIdc = (nalUnit[0] & 0x60) >>> 5;

  if (lastOptions) {
    lastOptions.nal_unit_type = nalUnitType;
    lastOptions.nal_ref_idc = nalRefIdc;
  }
  var nalObject = undefined;
  var newOptions = undefined;

  switch (nalUnitType) {
    case 0x01:
      nalObject = _bitStreamsH264.sliceLayerWithoutPartitioning.decode(nalData, lastOptions);
      nalObject.type = 'slice_layer_without_partitioning_rbsp';
      nalObject.nal_ref_idc = nalRefIdc;
      nalObject.size = nalData.length;
      return nalObject;
    case 0x02:
      return {
        type: 'slice_data_partition_a_layer_rbsp',
        size: nalData.length
      };
      break;
    case 0x03:
      return {
        type: 'slice_data_partition_b_layer_rbsp',
        size: nalData.length
      };
    case 0x04:
      return {
        type: 'slice_data_partition_c_layer_rbsp',
        size: nalData.length
      };
    case 0x05:
      newOptions = mergePS(lastOptions, { idrPicFlag: 1 });
      nalObject = _bitStreamsH264.sliceLayerWithoutPartitioning.decode(nalData, newOptions);
      nalObject.type = 'slice_layer_without_partitioning_rbsp_idr';
      nalObject.nal_ref_idc = nalRefIdc;
      nalObject.size = nalData.length;
      return nalObject;
    case 0x06:
      nalObject = _bitStreamsH264.supplementalEnhancementInformation.decode(nalData, lastOptions);
      nalObject.type = 'sei_message_rbsp';
      nalObject.size = nalData.length;
      return nalObject;
    case 0x07:
      lastSPS = _bitStreamsH264.seqParameterSet.decode(nalData);
      lastOptions = mergePS(lastPPS, lastSPS);
      lastSPS.type = 'seq_parameter_set_rbsp';
      lastSPS.size = nalData.length;
      return lastSPS;
    case 0x08:
      lastPPS = _bitStreamsH264.picParameterSet.decode(nalData);
      lastOptions = mergePS(lastPPS, lastSPS);
      lastPPS.type = 'pic_parameter_set_rbsp';
      lastPPS.size = nalData.length;
      return lastPPS;
    case 0x09:
      nalObject = _bitStreamsH264.accessUnitDelimiter.decode(nalData);
      nalObject.type = 'access_unit_delimiter_rbsp';
      nalObject.size = nalData.length;
      return nalObject;
    case 0x0A:
      return {
        type: 'end_of_seq_rbsp',
        size: nalData.length
      };
    case 0x0B:
      return {
        type: 'end_of_stream_rbsp',
        size: nalData.length
      };
    case 0x0C:
      return {
        type: 'filler_data_rbsp',
        size: nalData.length
      };
    case 0x0D:
      return {
        type: 'seq_parameter_set_extension_rbsp',
        size: nalData.length
      };
    case 0x0E:
      return {
        type: 'prefix_nal_unit_rbsp',
        size: nalData.length
      };
    case 0x0F:
      return {
        type: 'subset_seq_parameter_set_rbsp',
        size: nalData.length
      };
    case 0x10:
      return {
        type: 'depth_parameter_set_rbsp',
        size: nalData.length
      };
    case 0x13:
      return {
        type: 'slice_layer_without_partitioning_rbsp_aux',
        size: nalData.length
      };
    case 0x14:
    case 0x15:
      return {
        type: 'slice_layer_extension_rbsp',
        size: nalData.length
      };
    default:
      return {
        type: 'INVALID NAL-UNIT-TYPE - ' + nalUnitType,
        size: nalData.length
      };
  }
};
},{"../../bit-streams/h264":6}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _commonNalParse = require('./common/nal-parse');

var _commonDataToHexJs = require('./common/data-to-hex.js');

var _commonDataToHexJs2 = _interopRequireDefault(_commonDataToHexJs);

var tagTypes = {
  0x08: 'audio',
  0x09: 'video',
  0x12: 'metadata'
},
    hex = function hex(val) {
  return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();
},
    hexStringList = function hexStringList(data) {
  var arr = [],
      i;

  while (data.byteLength > 0) {
    i = 0;
    arr.push(hex(data[i++]));
    data = data.subarray(i);
  }
  return arr.join(' ');
},
    parseAVCTag = function parseAVCTag(tag, obj) {
  var avcPacketTypes = ['AVC Sequence Header', 'AVC NALU', 'AVC End-of-Sequence'],
      compositionTime = tag[1] & parseInt('01111111', 2) << 16 | tag[2] << 8 | tag[3];

  obj = obj || {};

  obj.avcPacketType = avcPacketTypes[tag[0]];
  obj.CompositionTime = tag[1] & parseInt('10000000', 2) ? -compositionTime : compositionTime;

  obj.data = tag.subarray(4);
  if (tag[0] === 0) {
    obj.type = 'video-metadata';
  }

  return obj;
},
    parseVideoTag = function parseVideoTag(tag, obj) {
  var frameTypes = ['Unknown', 'Keyframe (for AVC, a seekable frame)', 'Inter frame (for AVC, a nonseekable frame)', 'Disposable inter frame (H.263 only)', 'Generated keyframe (reserved for server use only)', 'Video info/command frame'],
      codecID = tag[0] & parseInt('00001111', 2);

  obj = obj || {};

  obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];
  obj.codecID = codecID;

  if (codecID === 7) {
    return parseAVCTag(tag.subarray(1), obj);
  }
  return obj;
},
    parseAACTag = function parseAACTag(tag, obj) {
  var packetTypes = ['AAC Sequence Header', 'AAC Raw'];

  obj = obj || {};

  obj.aacPacketType = packetTypes[tag[0]];
  obj.data = tag.subarray(1);

  return obj;
},
    parseAudioTag = function parseAudioTag(tag, obj) {
  var formatTable = ['Linear PCM, platform endian', 'ADPCM', 'MP3', 'Linear PCM, little endian', 'Nellymoser 16-kHz mono', 'Nellymoser 8-kHz mono', 'Nellymoser', 'G.711 A-law logarithmic PCM', 'G.711 mu-law logarithmic PCM', 'reserved', 'AAC', 'Speex', 'MP3 8-Khz', 'Device-specific sound'],
      samplingRateTable = ['5.5-kHz', '11-kHz', '22-kHz', '44-kHz'],
      soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;

  obj = obj || {};

  obj.soundFormat = formatTable[soundFormat];
  obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];
  obj.soundSize = (tag[0] & parseInt('00000010', 2)) >>> 1 ? '16-bit' : '8-bit';
  obj.soundType = tag[0] & parseInt('00000001', 2) ? 'Stereo' : 'Mono';

  if (soundFormat === 10) {
    return parseAACTag(tag.subarray(1), obj);
  }
  return obj;
},
    parseGenericTag = function parseGenericTag(tag) {
  return {
    type: tagTypes[tag[0]],
    dataSize: tag[1] << 16 | tag[2] << 8 | tag[3],
    timestamp: tag[7] << 24 | tag[4] << 16 | tag[5] << 8 | tag[6],
    streamID: tag[8] << 16 | tag[9] << 8 | tag[10]
  };
},
    inspectFlvTag = function inspectFlvTag(tag) {
  var header = parseGenericTag(tag);
  switch (tag[0]) {
    case 0x08:
      parseAudioTag(tag.subarray(11), header);
      break;
    case 0x09:
      parseVideoTag(tag.subarray(11), header);
      break;
    case 0x12:
  }
  return header;
},
    inspectFlv = function inspectFlv(bytes) {
  var i = 9,
      // header
  dataSize,
      parsedResults = [],
      tag;

  // traverse the tags
  i += 4; // skip previous tag size
  while (i < bytes.byteLength) {
    dataSize = bytes[i + 1] << 16;
    dataSize |= bytes[i + 2] << 8;
    dataSize |= bytes[i + 3];
    dataSize += 11;

    tag = bytes.subarray(i, i + dataSize);
    parsedResults.push(inspectFlvTag(tag));
    i += dataSize + 4;
  }
  return parsedResults;
};

var domifyFlv = function domifyFlv(flvTags) {
  var container = document.createElement('div');

  parsePESPackets(flvTags, container, 1);

  return container;
};

var parsePESPackets = function parsePESPackets(pesPackets, parent, depth) {
  pesPackets.forEach(function (packet) {
    var packetEl = document.createElement('div');
    domifyBox(parseNals(packet), parent, depth + 1);
  });
};

var parseNals = function parseNals(packet) {
  if (packet.type === 'video') {
    packet.nals = (0, _commonNalParse.nalParseAVCC)(packet.data);
    packet.nals.size = packet.data.length;
  }
  return packet;
};

var domifyBox = function domifyBox(box, parentNode, depth) {
  var isObject = function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  };
  var attributes = ['size', 'flags', 'type', 'version'];
  var specialProperties = ['boxes', 'nals', 'samples', 'packetCount'];
  var objectProperties = Object.keys(box).filter(function (key) {
    return isObject(box[key]) || Array.isArray(box[key]) && isObject(box[key][0]);
  });
  var propertyExclusions = attributes.concat(specialProperties).concat(objectProperties);
  var subProperties = Object.keys(box).filter(function (key) {
    return propertyExclusions.indexOf(key) === -1;
  });

  var boxNode = document.createElement('mp4-box');
  var propertyNode = document.createElement('mp4-properties');
  var subBoxesNode = document.createElement('mp4-boxes');
  var boxTypeNode = document.createElement('mp4-box-type');

  if (box.type) {
    boxTypeNode.textContent = box.type;

    if (depth > 1) {
      boxTypeNode.classList.add('collapsed');
    }

    boxNode.appendChild(boxTypeNode);
  }

  attributes.forEach(function (key) {
    if (typeof box[key] !== 'undefined') {
      boxNode.setAttribute('data-' + key, box[key]);
    }
  });

  if (subProperties.length) {
    subProperties.forEach(function (key) {
      makeProperty(key, box[key], propertyNode);
    });
    boxNode.appendChild(propertyNode);
  }

  if (box.boxes && box.boxes.length) {
    box.boxes.forEach(function (subBox) {
      return domifyBox(subBox, subBoxesNode, depth + 1);
    });
    boxNode.appendChild(subBoxesNode);
  } else if (objectProperties.length) {
    objectProperties.forEach(function (key) {
      if (Array.isArray(box[key])) {
        domifyBox({
          type: key,
          boxes: box[key],
          size: box[key].size
        }, subBoxesNode, depth + 1);
      } else {
        domifyBox(box[key], subBoxesNode, depth + 1);
      }
    });
    boxNode.appendChild(subBoxesNode);
  }

  parentNode.appendChild(boxNode);
};

var makeProperty = function makeProperty(name, value, parentNode) {
  var nameNode = document.createElement('mp4-name');
  var valueNode = document.createElement('mp4-value');
  var propertyNode = document.createElement('mp4-property');

  nameNode.setAttribute('data-name', name);
  nameNode.textContent = name;

  if (value instanceof Uint8Array || value instanceof Uint32Array) {
    var strValue = (0, _commonDataToHexJs2['default'])(value, '');
    var sliceOffset = 0;
    var lines = 0;

    for (; sliceOffset < strValue.length; sliceOffset++) {
      if (strValue[sliceOffset] === '\n') {
        if (++lines === 21) {
          sliceOffset++;
          break;
        }
      }
    }
    var truncValue = strValue.slice(0, sliceOffset);

    if (truncValue.length < strValue.length) {
      truncValue += '<' + (value.byteLength - 336) + 'b remaining of ' + value.byteLength + 'b total>';
    }

    valueNode.setAttribute('data-value', truncValue.toUpperCase());
    valueNode.innerHTML = truncValue;
    valueNode.classList.add('pre-like');
  } else if (Array.isArray(value)) {
    var strValue = '[' + value.join(', ') + ']';
    valueNode.setAttribute('data-value', strValue);
    valueNode.textContent = strValue;
  } else {
    valueNode.setAttribute('data-value', value);
    valueNode.textContent = value;
  }

  propertyNode.appendChild(nameNode);
  propertyNode.appendChild(valueNode);

  parentNode.appendChild(propertyNode);
};

exports['default'] = {
  inspect: inspectFlv,
  domify: domifyFlv
};
module.exports = exports['default'];
},{"./common/data-to-hex.js":15,"./common/nal-parse":16}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _mp4 = require('./mp4');

var _mp42 = _interopRequireDefault(_mp4);

var _ts = require('./ts');

var _ts2 = _interopRequireDefault(_ts);

var _flv = require('./flv');

var _flv2 = _interopRequireDefault(_flv);

exports['default'] = {
  mp4Inspector: _mp42['default'],
  tsInspector: _ts2['default'],
  flvInspector: _flv2['default']
};
module.exports = exports['default'];
},{"./flv":17,"./mp4":19,"./ts":20}],19:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bitStreamsH264 = require('../bit-streams/h264');

var _commonNalParse = require('./common/nal-parse');

var _commonDataToHexJs = require('./common/data-to-hex.js');

var _commonDataToHexJs2 = _interopRequireDefault(_commonDataToHexJs);

/**
 * Returns the string representation of an ASCII encoded four byte buffer.
 * @param buffer {Uint8Array} a four-byte buffer to translate
 * @return {string} the corresponding string
 */
var parseType = function parseType(buffer) {
  var result = '';
  result += String.fromCharCode(buffer[0]);
  result += String.fromCharCode(buffer[1]);
  result += String.fromCharCode(buffer[2]);
  result += String.fromCharCode(buffer[3]);
  return result;
};

var parseMp4Date = function parseMp4Date(seconds) {
  return new Date(seconds * 1000 - 2082844800000);
};

var parseSampleFlags = function parseSampleFlags(flags) {
  return {
    isLeading: (flags[0] & 0x0c) >>> 2,
    dependsOn: flags[0] & 0x03,
    isDependedOn: (flags[1] & 0xc0) >>> 6,
    hasRedundancy: (flags[1] & 0x30) >>> 4,
    paddingValue: (flags[1] & 0x0e) >>> 1,
    isNonSyncSample: flags[1] & 0x01,
    degradationPriority: flags[2] << 8 | flags[3]
  };
};

var lastSPS = undefined;
var lastPPS = undefined;
var lastOptions = undefined;

// registry of handlers for individual mp4 box types
var parse = {
  // codingname, not a first-class box type. stsd entries share the
  // same format as real boxes so the parsing infrastructure can be
  // shared
  avc1: function avc1(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    return {
      dataReferenceIndex: view.getUint16(6),
      width: view.getUint16(24),
      height: view.getUint16(26),
      horizresolution: view.getUint16(28) + view.getUint16(30) / 16,
      vertresolution: view.getUint16(32) + view.getUint16(34) / 16,
      frameCount: view.getUint16(40),
      depth: view.getUint16(74),
      config: inspectMp4(data.subarray(78, data.byteLength))
    };
  },
  avcC: function avcC(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      configurationVersion: data[0],
      avcProfileIndication: data[1],
      profileCompatibility: data[2],
      avcLevelIndication: data[3],
      lengthSizeMinusOne: data[4] & 0x03,
      sps: [],
      pps: []
    },
        numOfSequenceParameterSets = data[5] & 0x1f,
        numOfPictureParameterSets,
        nalSize,
        offset,
        i;

    // iterate past any SPSs
    offset = 6;
    for (i = 0; i < numOfSequenceParameterSets; i++) {
      nalSize = view.getUint16(offset);
      offset += 2;
      var nalData = (0, _bitStreamsH264.discardEmulationPrevention)(new Uint8Array(data.subarray(offset + 1, offset + nalSize)));
      lastSPS = _bitStreamsH264.seqParameterSet.decode(nalData);
      lastOptions = (0, _commonNalParse.mergePS)(lastPPS, lastSPS);
      result.sps.push(lastSPS);
      offset += nalSize;
    }
    // iterate past any PPSs
    numOfPictureParameterSets = data[offset];
    offset++;
    for (i = 0; i < numOfPictureParameterSets; i++) {
      nalSize = view.getUint16(offset);
      offset += 2;
      var nalData = (0, _bitStreamsH264.discardEmulationPrevention)(new Uint8Array(data.subarray(offset + 1, offset + nalSize)));
      lastPPS = _bitStreamsH264.picParameterSet.decode(nalData);
      lastOptions = (0, _commonNalParse.mergePS)(lastPPS, lastSPS);
      result.pps.push(lastPPS);
      offset += nalSize;
    }
    return result;
  },
  btrt: function btrt(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    return {
      bufferSizeDB: view.getUint32(0),
      maxBitrate: view.getUint32(4),
      avgBitrate: view.getUint32(8)
    };
  },
  esds: function esds(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      esId: data[6] << 8 | data[7],
      streamPriority: data[8] & 0x1f,
      decoderConfig: {
        objectProfileIndication: data[11],
        streamType: data[12] >>> 2 & 0x3f,
        bufferSize: data[13] << 16 | data[14] << 8 | data[15],
        maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],
        avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],
        decoderConfigDescriptor: {
          tag: data[24],
          length: data[25],
          audioObjectType: data[26] >>> 3 & 0x1f,
          samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,
          channelConfiguration: data[27] >>> 3 & 0x0f
        }
      }
    };
  },
  ftyp: function ftyp(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      majorBrand: parseType(data.subarray(0, 4)),
      minorVersion: view.getUint32(4),
      compatibleBrands: []
    },
        i = 8;
    while (i < data.byteLength) {
      result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));
      i += 4;
    }
    return result;
  },
  dinf: function dinf(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  dref: function dref(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      dataReferences: inspectMp4(data.subarray(8))
    };
  },
  hdlr: function hdlr(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: view.getUint8(0),
      flags: new Uint8Array(data.subarray(1, 4)),
      handlerType: parseType(data.subarray(8, 12)),
      name: ''
    },
        i = 8;

    // parse out the name field
    for (i = 24; i < data.byteLength; i++) {
      if (data[i] === 0x00) {
        // the name field is null-terminated
        i++;
        break;
      }
      result.name += String.fromCharCode(data[i]);
    }
    // decode UTF-8 to javascript's internal representation
    // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html
    result.name = decodeURIComponent(global.escape(result.name));

    return result;
  },
  mdat: function mdat(data) {
    return {
      byteLength: data.byteLength,
      nals: (0, _commonNalParse.nalParseAVCC)(data),
      size: data.byteLength
    };
  },
  mdhd: function mdhd(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        i = 4,
        language,
        result = {
      version: view.getUint8(0),
      flags: new Uint8Array(data.subarray(1, 4)),
      language: ''
    };
    if (result.version === 1) {
      i += 4;
      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 8;
      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 4;
      result.timescale = view.getUint32(i);
      i += 8;
      result.duration = view.getUint32(i); // truncating top 4 bytes
    } else {
        result.creationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.modificationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.timescale = view.getUint32(i);
        i += 4;
        result.duration = view.getUint32(i);
      }
    i += 4;
    // language is stored as an ISO-639-2/T code in an array of three 5-bit fields
    // each field is the packed difference between its ASCII value and 0x60
    language = view.getUint16(i);
    result.language += String.fromCharCode((language >> 10) + 0x60);
    result.language += String.fromCharCode(((language & 0x03c0) >> 5) + 0x60);
    result.language += String.fromCharCode((language & 0x1f) + 0x60);

    return result;
  },
  mdia: function mdia(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  mfhd: function mfhd(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]
    };
  },
  minf: function minf(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  // codingname, not a first-class box type. stsd entries share the
  // same format as real boxes so the parsing infrastructure can be
  // shared
  mp4a: function mp4a(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      // 6 bytes reserved
      dataReferenceIndex: view.getUint16(6),
      // 4 + 4 bytes reserved
      channelcount: view.getUint16(16),
      samplesize: view.getUint16(18),
      // 2 bytes pre_defined
      // 2 bytes reserved
      samplerate: view.getUint16(24) + view.getUint16(26) / 65536
    };

    // if there are more bytes to process, assume this is an ISO/IEC
    // 14496-14 MP4AudioSampleEntry and parse the ESDBox
    if (data.byteLength > 28) {
      result.streamDescriptor = inspectMp4(data.subarray(28))[0];
    }
    return result;
  },
  moof: function moof(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  moov: function moov(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  mvex: function mvex(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  mvhd: function mvhd(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        i = 4,
        result = {
      version: view.getUint8(0),
      flags: new Uint8Array(data.subarray(1, 4))
    };

    if (result.version === 1) {
      i += 4;
      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 8;
      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 4;
      result.timescale = view.getUint32(i);
      i += 8;
      result.duration = view.getUint32(i); // truncating top 4 bytes
    } else {
        result.creationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.modificationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.timescale = view.getUint32(i);
        i += 4;
        result.duration = view.getUint32(i);
      }
    i += 4;

    // convert fixed-point, base 16 back to a number
    result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;
    i += 4;
    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;
    i += 2;
    i += 2;
    i += 2 * 4;
    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));
    i += 9 * 4;
    i += 6 * 4;
    result.nextTrackId = view.getUint32(i);
    return result;
  },
  pdin: function pdin(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    return {
      version: view.getUint8(0),
      flags: new Uint8Array(data.subarray(1, 4)),
      rate: view.getUint32(4),
      initialDelay: view.getUint32(8)
    };
  },
  sdtp: function sdtp(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    },
        i;

    for (i = 4; i < data.byteLength; i++) {
      result.samples.push({
        dependsOn: (data[i] & 0x30) >> 4,
        isDependedOn: (data[i] & 0x0c) >> 2,
        hasRedundancy: data[i] & 0x03
      });
    }
    return result;
  },
  sidx: function sidx(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      references: [],
      referenceId: view.getUint32(4),
      timescale: view.getUint32(8),
      earliestPresentationTime: view.getUint32(12),
      firstOffset: view.getUint32(16)
    },
        referenceCount = view.getUint16(22),
        i;

    for (i = 24; referenceCount; i += 12, referenceCount--) {
      result.references.push({
        referenceType: (data[i] & 0x80) >>> 7,
        referencedSize: view.getUint32(i) & 0x7FFFFFFF,
        subsegmentDuration: view.getUint32(i + 4),
        startsWithSap: !!(data[i + 8] & 0x80),
        sapType: (data[i + 8] & 0x70) >>> 4,
        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF
      });
    }

    return result;
  },
  smhd: function smhd(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      balance: data[4] + data[5] / 256
    };
  },
  stbl: function stbl(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  stco: function stco(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      chunkOffsets: []
    },
        entryCount = view.getUint32(4),
        i;
    for (i = 8; entryCount; i += 4, entryCount--) {
      result.chunkOffsets.push(view.getUint32(i));
    }
    return result;
  },
  stsc: function stsc(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        entryCount = view.getUint32(4),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      sampleToChunks: []
    },
        i;
    for (i = 8; entryCount; i += 12, entryCount--) {
      result.sampleToChunks.push({
        firstChunk: view.getUint32(i),
        samplesPerChunk: view.getUint32(i + 4),
        sampleDescriptionIndex: view.getUint32(i + 8)
      });
    }
    return result;
  },
  stsd: function stsd(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      sampleDescriptions: inspectMp4(data.subarray(8))
    };
  },
  stsz: function stsz(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      sampleSize: view.getUint32(4),
      entries: []
    },
        i;
    for (i = 12; i < data.byteLength; i += 4) {
      result.entries.push(view.getUint32(i));
    }
    return result;
  },
  stts: function stts(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      timeToSamples: []
    },
        entryCount = view.getUint32(4),
        i;

    for (i = 8; entryCount; i += 8, entryCount--) {
      result.timeToSamples.push({
        sampleCount: view.getUint32(i),
        sampleDelta: view.getUint32(i + 4)
      });
    }
    return result;
  },
  styp: function styp(data) {
    return parse.ftyp(data);
  },
  tfdt: function tfdt(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      baseMediaDecodeTime: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]
    };
    if (result.version === 1) {
      result.baseMediaDecodeTime *= Math.pow(2, 32);
      result.baseMediaDecodeTime += data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11];
    }
    return result;
  },
  tfhd: function tfhd(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4)
    },
        baseDataOffsetPresent = result.flags[2] & 0x01,
        sampleDescriptionIndexPresent = result.flags[2] & 0x02,
        defaultSampleDurationPresent = result.flags[2] & 0x08,
        defaultSampleSizePresent = result.flags[2] & 0x10,
        defaultSampleFlagsPresent = result.flags[2] & 0x20,
        i;

    i = 8;
    if (baseDataOffsetPresent) {
      i += 4; // truncate top 4 bytes
      result.baseDataOffset = view.getUint32(12);
      i += 4;
    }
    if (sampleDescriptionIndexPresent) {
      result.sampleDescriptionIndex = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleDurationPresent) {
      result.defaultSampleDuration = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleSizePresent) {
      result.defaultSampleSize = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleFlagsPresent) {
      result.defaultSampleFlags = view.getUint32(i);
    }
    return result;
  },
  tkhd: function tkhd(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        i = 4,
        result = {
      version: view.getUint8(0),
      flags: new Uint8Array(data.subarray(1, 4))
    };
    if (result.version === 1) {
      i += 4;
      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 8;
      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes
      i += 4;
      result.trackId = view.getUint32(i);
      i += 4;
      i += 8;
      result.duration = view.getUint32(i); // truncating top 4 bytes
    } else {
        result.creationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.modificationTime = parseMp4Date(view.getUint32(i));
        i += 4;
        result.trackId = view.getUint32(i);
        i += 4;
        i += 4;
        result.duration = view.getUint32(i);
      }
    i += 4;
    i += 2 * 4;
    result.layer = view.getUint16(i);
    i += 2;
    result.alternateGroup = view.getUint16(i);
    i += 2;
    // convert fixed-point, base 16 back to a number
    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;
    i += 2;
    i += 2;
    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));
    i += 9 * 4;
    result.width = view.getUint16(i) + view.getUint16(i + 2) / 16;
    i += 4;
    result.height = view.getUint16(i) + view.getUint16(i + 2) / 16;
    return result;
  },
  traf: function traf(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  trak: function trak(data) {
    return {
      boxes: inspectMp4(data)
    };
  },
  trex: function trex(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4),
      defaultSampleDescriptionIndex: view.getUint32(8),
      defaultSampleDuration: view.getUint32(12),
      defaultSampleSize: view.getUint32(16),
      sampleDependsOn: data[20] & 0x03,
      sampleIsDependedOn: (data[21] & 0xc0) >> 6,
      sampleHasRedundancy: (data[21] & 0x30) >> 4,
      samplePaddingValue: (data[21] & 0x0e) >> 1,
      sampleIsDifferenceSample: !!(data[21] & 0x01),
      sampleDegradationPriority: view.getUint16(22)
    };
  },
  trun: function trun(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    },
        view = new DataView(data.buffer, data.byteOffset, data.byteLength),
        dataOffsetPresent = result.flags[2] & 0x01,
        firstSampleFlagsPresent = result.flags[2] & 0x04,
        sampleDurationPresent = result.flags[1] & 0x01,
        sampleSizePresent = result.flags[1] & 0x02,
        sampleFlagsPresent = result.flags[1] & 0x04,
        sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,
        sampleCount = view.getUint32(4),
        offset = 8,
        sample;

    if (dataOffsetPresent) {
      result.dataOffset = view.getUint32(offset);
      offset += 4;
    }

    if (firstSampleFlagsPresent && sampleCount) {
      sample = {
        flags: parseSampleFlags(data.subarray(offset, offset + 4))
      };
      offset += 4;
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        sample.compositionTimeOffset = view.getUint32(offset);
        offset += 4;
      }
      result.samples.push(sample);
      sampleCount--;
    }

    while (sampleCount--) {
      sample = {};
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset);
        offset += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset);
        offset += 4;
      }
      if (sampleFlagsPresent) {
        sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));
        offset += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        sample.compositionTimeOffset = view.getUint32(offset);
        offset += 4;
      }
      result.samples.push(sample);
    }
    return result;
  },
  'url ': function url(data) {
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4))
    };
  },
  vmhd: function vmhd(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    return {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      graphicsmode: view.getUint16(4),
      opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])
    };
  }
};

/**
 * Return a javascript array of box objects parsed from an ISO base
 * media file.
 * @param data {Uint8Array} the binary data of the media to be inspected
 * @return {array} a javascript array of potentially nested box objects
 */
var inspectMp4 = function inspectMp4(data) {
  var i = 0,
      result = [],
      view,
      size,
      type,
      end,
      box,
      seenMOOV = false,
      pendingMDAT = null;

  // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API
  var ab = new ArrayBuffer(data.length);
  var v = new Uint8Array(ab);
  for (var z = 0; z < data.length; ++z) {
    v[z] = data[z];
  }
  view = new DataView(ab);

  while (i < data.byteLength) {
    // parse box data
    size = view.getUint32(i);
    type = parseType(data.subarray(i + 4, i + 8));
    end = size > 1 ? i + size : data.byteLength;

    if (type === 'moov') {
      seenMOOV = true;
    }

    if (type === 'mdat' && !seenMOOV) {
      pendingMDAT = data.subarray(i + 8, end);
    } else {
      // parse type-specific data
      box = (parse[type] || function (data) {
        return {
          data: data
        };
      })(data.subarray(i + 8, end));
      box.size = size;
      box.type = type;
      // store this box and move to the next
      result.push(box);
    }

    if (pendingMDAT && seenMOOV) {
      box = parse['mdat'](pendingMDAT);
      box.size = pendingMDAT.byteLength;
      box.type = 'mdat';
      // store this box and move to the next
      result.push(box);
      pendingMDAT = null;
    }

    i = end;
  }
  return result;
};

/**
 * Returns a textual representation of the javascript represtentation
 * of an MP4 file. You can use it as an alternative to
 * JSON.stringify() to compare inspected MP4s.
 * @param inspectedMp4 {array} the parsed array of boxes in an MP4
 * file
 * @param depth {number} (optional) the number of ancestor boxes of
 * the elements of inspectedMp4. Assumed to be zero if unspecified.
 * @return {string} a text representation of the parsed MP4
 */
var textifyMp4 = function textifyMp4(inspectedMp4, depth) {
  var indent;
  depth = depth || 0;
  indent = new Array(depth * 2 + 1).join(' ');

  // iterate over all the boxes
  return inspectedMp4.map(function (box, index) {

    // list the box type first at the current indentation level
    return indent + box.type + '\n' +

    // the type is already included and handle child boxes separately
    Object.keys(box).filter(function (key) {
      return key !== 'type' && key !== 'boxes';

      // output all the box properties
    }).map(function (key) {
      var prefix = indent + '  ' + key + ': ',
          value = box[key];

      // print out raw bytes as hexademical
      if (value instanceof Uint8Array || value instanceof Uint32Array) {
        return prefix + (0, _commonDataToHexJs2['default'])(value, indent);
      }

      // stringify generic objects
      return prefix + JSON.stringify(value, null, 2).split('\n').map(function (line, index) {
        if (index === 0) {
          return line;
        }
        return indent + '  ' + line;
      }).join('\n');
    }).join('\n') + (

    // recursively textify the child boxes
    box.boxes ? '\n' + textifyMp4(box.boxes, depth + 1) : '');
  }).join('\n');
};

var domifyMp4 = function domifyMp4(inspectedMp4) {
  var topLevelObject = {
    type: 'mp4',
    boxes: inspectedMp4,
    size: inspectedMp4.reduce(function (sum, box) {
      return sum + box.size;
    }, 0)
  };

  var container = document.createElement('div');

  domifyBox(topLevelObject, container, 1);

  return container;
};

/*
<boxType size="100" flags>
  <properties>
    <name></name><value></value>
    <name></name><value></value>
  </properties>
  <boxes>
  </boxes>
</boxType>
*/

var domifyBox = function domifyBox(box, parentNode, depth) {
  var isObject = function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  };
  var attributes = ['size', 'flags', 'type', 'version'];
  var specialProperties = ['boxes', 'nals', 'samples'];
  var objectProperties = Object.keys(box).filter(function (key) {
    return isObject(box[key]) || Array.isArray(box[key]) && isObject(box[key][0]);
  });
  var propertyExclusions = attributes.concat(specialProperties).concat(objectProperties);
  var subProperties = Object.keys(box).filter(function (key) {
    return propertyExclusions.indexOf(key) === -1;
  });

  var boxNode = document.createElement('mp4-box');
  var propertyNode = document.createElement('mp4-properties');
  var subBoxesNode = document.createElement('mp4-boxes');
  var boxTypeNode = document.createElement('mp4-box-type');

  if (box.type) {
    boxTypeNode.textContent = box.type;

    if (depth > 1) {
      boxTypeNode.classList.add('collapsed');
    }

    boxNode.appendChild(boxTypeNode);
  }

  attributes.forEach(function (key) {
    if (typeof box[key] !== 'undefined') {
      boxNode.setAttribute('data-' + key, box[key]);
    }
  });

  if (subProperties.length) {
    subProperties.forEach(function (key) {
      makeProperty(key, box[key], propertyNode);
    });
    boxNode.appendChild(propertyNode);
  }

  if (box.boxes && box.boxes.length) {
    box.boxes.forEach(function (subBox) {
      return domifyBox(subBox, subBoxesNode, depth + 1);
    });
    boxNode.appendChild(subBoxesNode);
  } else if (objectProperties.length) {
    objectProperties.forEach(function (key) {
      if (Array.isArray(box[key])) {
        domifyBox({
          type: key,
          boxes: box[key],
          size: box[key].size
        }, subBoxesNode, depth + 1);
      } else {
        domifyBox(box[key], subBoxesNode, depth + 1);
      }
    });
    boxNode.appendChild(subBoxesNode);
  }

  parentNode.appendChild(boxNode);
};

var makeProperty = function makeProperty(name, value, parentNode) {
  var nameNode = document.createElement('mp4-name');
  var valueNode = document.createElement('mp4-value');
  var propertyNode = document.createElement('mp4-property');

  nameNode.setAttribute('data-name', name);
  nameNode.textContent = name;

  if (value instanceof Uint8Array || value instanceof Uint32Array) {
    var strValue = (0, _commonDataToHexJs2['default'])(value, '');
    var sliceOffset = 0;
    var lines = 0;

    for (; sliceOffset < strValue.length; sliceOffset++) {
      if (strValue[sliceOffset] === '\n') {
        if (++lines === 21) {
          sliceOffset++;
          break;
        }
      }
    }
    var truncValue = strValue.slice(0, sliceOffset);

    if (truncValue.length < strValue.length) {
      truncValue += '<' + (value.byteLength - 336) + 'b remaining of ' + value.byteLength + 'b total>';
    }

    valueNode.setAttribute('data-value', truncValue.toUpperCase());
    valueNode.innerHTML = truncValue;
    valueNode.classList.add('pre-like');
  } else if (Array.isArray(value)) {
    var strValue = '[' + value.join(', ') + ']';
    valueNode.setAttribute('data-value', strValue);
    valueNode.textContent = strValue;
  } else {
    valueNode.setAttribute('data-value', value);
    valueNode.textContent = value;
  }

  propertyNode.appendChild(nameNode);
  propertyNode.appendChild(valueNode);

  parentNode.appendChild(propertyNode);
};

exports['default'] = {
  inspect: inspectMp4,
  textify: textifyMp4,
  domify: domifyMp4
};
module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../bit-streams/h264":6,"./common/data-to-hex.js":15,"./common/nal-parse":16}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _commonNalParse = require('./common/nal-parse');

var _commonAacParse = require('./common/aac-parse');

var _commonDataToHexJs = require('./common/data-to-hex.js');

var _commonDataToHexJs2 = _interopRequireDefault(_commonDataToHexJs);

// constants
var MP2T_PACKET_LENGTH = 188; // in bytes
var SYNC_BYTE = 0x47;
var STREAM_TYPES = {
  h264: 0x1b,
  adts: 0x0f,
  metadata: 0x15
};

/**
 * Splits an incoming stream of binary data into MPEG-2 Transport
 * Stream packets.
 */
var parseTransportStream = function parseTransportStream(bytes) {
  var startIndex = 0,
      endIndex = MP2T_PACKET_LENGTH,
      lastSync = -1,
      packets = [];

  // While we have enough data for a packet
  while (endIndex < bytes.byteLength) {
    // Look for a pair of start and end sync bytes in the data..
    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
      if (lastSync !== -1) {
        packets.push({
          type: 'unknown-bytes',
          data: bytes.subarray(lastSync, startIndex)
        });
        lastSync = -1;
      }

      // We found a packet so emit it and jump one whole packet forward in
      // the stream
      packets.push({
        type: 'transportstream-packet',
        data: bytes.subarray(startIndex, endIndex)
      });
      startIndex += MP2T_PACKET_LENGTH;
      endIndex += MP2T_PACKET_LENGTH;
      continue;
    }
    // If we get here, we have somehow become de-synchronized and we need to step
    // forward one byte at a time until we find a pair of sync bytes that denote
    // a packet
    lastSync = startIndex;
    startIndex++;
    endIndex++;
  }

  if (startIndex + MP2T_PACKET_LENGTH === bytes.byteLength) {
    // We found a final packet so emit it and jump one whole packet forward in
    // the stream
    packets.push({
      type: 'transportstream-packet',
      data: bytes.subarray(startIndex, endIndex)
    });
    startIndex += MP2T_PACKET_LENGTH;
    endIndex += MP2T_PACKET_LENGTH;
  }

  // If there was some data left over at the end of the segment that couldn't
  // possibly be a whole packet, emit it for completeness
  if (startIndex < bytes.byteLength) {
    packets.push({
      type: 'unknown-bytes',
      data: bytes.subarray(startIndex)
    });
  }

  return parseTransportStreamPackets(packets);
};

/**
 * Accepts an MP2T TransportPacketStream and emits data events with parsed
 * forms of the individual transport stream packets.
 */
var parseTransportStreamPackets = function parseTransportStreamPackets(packets) {
  var packetsPendingPmt = [];
  var packetsPendingPmtPid = [];
  var programMapTable = null;
  var pmtPid = null;

  var processPmtOrPes = function processPmtOrPes(packet) {
    if (packet.pid === pmtPid) {
      packet.content.type = 'pmt';
      parsePsi(packet);
    } else if (programMapTable === null) {
      // When we have not seen a PMT yet, defer further processing of
      // PES packets until one has been parsed
      packetsPendingPmt.push(packet);
    } else {
      processPes(packet);
    }
  };

  var processPes = function processPes(packet) {
    var pmtTable = programMapTable[packet.pid];
    if (pmtTable) {
      packet.content.streamType = pmtTable.streamType;
    } else {
      packet.content.streamType = ' unknown';
    }
    packet.content.type = 'pes';
  };

  var parsePsi = function parsePsi(packet) {
    var offset = 0;
    var psi = packet.content;
    var payload = psi.data;

    // PSI packets may be split into multiple sections and those
    // sections may be split into multiple packets. If a PSI
    // section starts in this packet, the payload_unit_start_indicator
    // will be true and the first byte of the payload will indicate
    // the offset from the current position to the start of the
    // section.
    if (packet.payloadUnitStartIndicator) {
      offset += payload[0] + 1;
    }

    psi.data = payload.subarray(offset);

    if (psi.type === 'pat') {
      parsePat(packet);
    } else {
      parsePmt(packet);
    }
  };

  var parsePat = function parsePat(packet) {
    var pat = packet.content;
    var payload = pat.data;

    pat.sectionNumber = payload[7]; // eslint-disable-line camelcase
    pat.lastSectionNumber = payload[8]; // eslint-disable-line camelcase

    // skip the PSI header and parse the first PMT entry
    pmtPid = (payload[10] & 0x1F) << 8 | payload[11];
    pat.pmtPid = pmtPid;

    // if there are any packets waiting for a PMT PID to be found, process them now
    while (packetsPendingPmtPid.length) {
      processPmtOrPes(packetsPendingPmtPid.shift());
    }
  };

  /**
   * Parse out the relevant fields of a Program Map Table (PMT).
   * @param payload {Uint8Array} the PMT-specific portion of an MP2T
   * packet. The first byte in this array should be the table_id
   * field.
   * @param pmt {object} the object that should be decorated with
   * fields parsed from the PMT.
   */
  var parsePmt = function parsePmt(packet) {
    var pmt = packet.content;
    var payload = pmt.data;

    var sectionLength, tableEnd, programInfoLength, offset;

    // PMTs can be sent ahead of the time when they should actually
    // take effect. We don't believe this should ever be the case
    // for HLS but we'll ignore "forward" PMT declarations if we see
    // them. Future PMT declarations have the current_next_indicator
    // set to zero.
    if (!(payload[5] & 0x01)) {
      return;
    }

    // overwrite any existing program map table
    programMapTable = {};

    // the mapping table ends at the end of the current section
    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];
    tableEnd = 3 + sectionLength - 4;

    // to determine where the table is, we have to figure out how
    // long the program info descriptors are
    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];

    // advance the offset to the first entry in the mapping table
    offset = 12 + programInfoLength;

    while (offset < tableEnd) {
      var esInfoLength = (payload[offset + 3] & 0x0F) << 8 | payload[offset + 4];
      // add an entry that maps the elementary_pid to the stream_type
      programMapTable[(payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]] = {
        streamType: payload[offset],
        esInfo: payload.subarray(offset + 5, offset + 5 + esInfoLength)
      };

      // move to the next table entry
      // skip past the elementary stream descriptors, if present
      offset += esInfoLength + 5;
    }

    // record the map on the packet as well
    pmt.programMapTable = programMapTable;

    // if there are any packets waiting for a PMT to be found, process them now
    while (packetsPendingPmt.length) {
      processPes(packetsPendingPmt.shift());
    }
  };

  /**
   * Deliver a new MP2T packet to the stream.
   */
  var parsePacket = function parsePacket(packet) {
    var offset = 4;
    var payload = packet.data;
    var content = {};

    packet.payloadUnitStartIndicator = !!(payload[1] & 0x40);

    // pid is a 13-bit field starting at the last bit of packet[1]
    packet.pid = payload[1] & 0x1f;
    packet.pid <<= 8;
    packet.pid |= payload[2];
    packet.content = content;

    // if an adaption field is present, its length is specified by the
    // fifth byte of the TS packet header. The adaptation field is
    // used to add stuffing to PES packets that don't fill a complete
    // TS packet, and to specify some forms of timing and control data
    // that we do not currently use.
    if ((payload[3] & 0x30) >>> 4 > 0x01) {
      offset += payload[offset] + 1;
    }

    content.data = payload.subarray(offset);

    // parse the rest of the packet based on the type
    if (packet.pid === 0) {
      content.type = 'pat';
      parsePsi(packet);
      return packet;
    }

    if (pmtPid === null) {
      packetsPendingPmtPid.push(packet);
      return packet;
    }

    return processPmtOrPes(packet);
  };

  packets.forEach(function (packet) {
    if (packet.type === 'transportstream-packet') {
      parsePacket(packet);
    } else {
      packet.content = {};
    }
  });

  return packets;
};

/**
 * Reconsistutes program elementary stream (PES) packets from parsed
 * transport stream packets. That is, if you pipe an
 * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output
 * events will be events which capture the bytes for individual PES
 * packets plus relevant metadata that has been extracted from the
 * container.
 */
var parsePesPackets = function parsePesPackets(packets) {
  var completeEs = [],

  // PES packet fragments
  streams = [],
      parsePes = function parsePes(payload, pes) {
    var ptsDtsFlags;

    // find out if this packets starts a new keyframe
    pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;
    // PES packets may be annotated with a PTS value, or a PTS value
    // and a DTS value. Determine what combination of values is
    // available to work with.
    ptsDtsFlags = payload[7];

    // PTS and DTS are normally stored as a 33-bit number.  Javascript
    // performs all bitwise operations on 32-bit integers but javascript
    // supports a much greater range (52-bits) of integer using standard
    // mathematical operations.
    // We construct a 31-bit value using bitwise operators over the 31
    // most significant bits and then multiply by 4 (equal to a left-shift
    // of 2) before we add the final 2 least significant bits of the
    // timestamp (equal to an OR.)
    if (ptsDtsFlags & 0xC0) {
      // the PTS and DTS are not written out directly. For information
      // on how they are encoded, see
      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
      pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;
      pes.pts *= 4; // Left shift by 2
      pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs
      pes.dts = pes.pts;
      if (ptsDtsFlags & 0x40) {
        pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;
        pes.dts *= 4; // Left shift by 2
        pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs
      }
    }

    // the data section starts immediately after the PES header.
    // pes_header_data_length specifies the number of header bytes
    // that follow the last byte of the field.
    pes.data = payload.subarray(9 + payload[8]);
  },
      flushStream = function flushStream(stream) {
    var packetData = new Uint8Array(stream.size),
        event = {
      type: stream.streamType
    },
        i = 0,
        fragment;

    // do nothing if there is no buffered data
    if (!stream.data.length) {
      return;
    }
    event.pid = stream.pid;
    event.packetCount = stream.data.length;
    event.tsPacketIndices = stream.tsPacketIndices;
    // reassemble the packet
    while (stream.data.length) {
      fragment = stream.data.shift();

      packetData.set(fragment.data, i);
      i += fragment.data.byteLength;
    }

    // parse assembled packet's PES header
    parsePes(packetData, event);

    if (event.type === 'video') {
      parseNals(event);
    }

    if (event.type === 'audio') {
      parseAac(event);
    }

    stream.size = 0;
    stream.tsPacketIndices = [];

    completeEs.push(event);
  };

  var packetTypes = {
    pat: function pat(packet, packetIndex) {
      var pat = packet.content;
      completeEs.push({
        pid: packet.pid,
        type: 'pat',
        packetCount: 1,
        sectionNumber: pat.sectionNumber,
        lastSectionNumber: pat.lastSectionNumber,
        tsPacketIndices: [packetIndex],
        pmtPid: pat.pmtPid,
        data: pat.data
      });
    },
    pes: function pes(packet, packetIndex) {
      var stream = undefined;
      var streamType = undefined;
      var pes = packet.content;

      if (!streams[packet.pid]) {
        stream = streams[packet.pid] = {
          data: [],
          tsPacketIndices: [],
          size: 0
        };

        switch (pes.streamType) {
          case STREAM_TYPES.h264:
            stream.streamType = 'video';
            break;
          case STREAM_TYPES.adts:
            stream.streamType = 'audio';
            break;
          case STREAM_TYPES.metadata:
            stream.streamType = 'timed-metadata';
            break;
          default:
            stream.streamType = 'unknown-' + packet.pid;
        }
      }

      stream = streams[packet.pid];

      // if a new packet is starting, we can flush the completed
      // packet
      if (packet.payloadUnitStartIndicator) {
        flushStream(stream);
      }

      stream.pid = packet.pid;
      stream.tsPacketIndices.push(packetIndex);
      // buffer this fragment until we are sure we've received the
      // complete payload
      stream.data.push(pes);
      stream.size += pes.data.byteLength;
    },
    pmt: function pmt(packet, packetIndex) {
      var pmt = packet.content;
      var programMapTable = pmt.programMapTable;
      var event = {
        pid: packet.pid,
        type: 'pmt',
        tracks: [],
        tsPacketIndices: [packetIndex],
        packetCount: 1,
        data: pmt.data
      };
      var k = undefined;
      var track = undefined;

      // translate streams to tracks
      for (k in programMapTable) {
        if (programMapTable.hasOwnProperty(k)) {
          track = {};

          track.id = +k;
          track.streamType = programMapTable[k].streamType;
          if (programMapTable[k].streamType === STREAM_TYPES.h264) {
            track.codec = 'avc';
            track.type = 'video';
          } else if (programMapTable[k].streamType === STREAM_TYPES.adts) {
            track.codec = 'adts';
            track.type = 'audio';
          } else if (programMapTable[k].streamType === STREAM_TYPES.metadata) {
            track.type = 'metadata';
          } else {
            track.type = 'unknown';
          }
          track.esInfo = programMapTable[k].esInfo;
          event.tracks.push(track);
        }
      }
      completeEs.push(event);
    }
  };

  var parsePacket = function parsePacket(packet, packetIndex) {
    switch (packet.content.type) {
      case 'pat':
      case 'pmt':
      case 'pes':
        packetTypes[packet.content.type](packet, packetIndex);
        break;
      default:
        break;
    }
  };

  packets.forEach(function (packet, packetIndex) {
    parsePacket(packet, packetIndex);
  });

  streams.forEach(function (stream) {
    flushStream(stream);
  });

  return completeEs;
};

var inspectTs = function inspectTs(data) {
  var object = {};
  var tsPackets = parseTransportStream(data);
  var pesPackets = parsePesPackets(tsPackets);

  object.tsMap = tsPackets;
  object.esMap = pesPackets;

  return object;
};

var domifyTs = function domifyTs(object) {
  var tsPackets = object.tsMap;
  var pesPackets = object.esMap;
  var container = document.createElement('div');

  parsePESPackets(pesPackets, container, 1);

  return container;
};

var parsePESPackets = function parsePESPackets(pesPackets, parent, depth) {
  pesPackets.forEach(function (packet) {
    var packetEl = document.createElement('div');
    domifyBox(packet, parent, depth + 1);
  });
};

var parseNals = function parseNals(packet) {
  packet.nals = (0, _commonNalParse.nalParseAnnexB)(packet.data);
  packet.nals.size = packet.data.length;

  return packet;
};

var parseAac = function parseAac(packet) {
  packet.adts = (0, _commonAacParse.parseAdts)(packet);
  packet.adts.ize = packet.data.length;

  return packet;
};

var domifyBox = function domifyBox(box, parentNode, depth) {
  var isObject = function isObject(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  };
  var attributes = ['size', 'flags', 'type', 'version'];
  var specialProperties = ['boxes', 'nals', 'samples', 'packetCount'];
  var objectProperties = Object.keys(box).filter(function (key) {
    return isObject(box[key]) || Array.isArray(box[key]) && isObject(box[key][0]);
  });
  var propertyExclusions = attributes.concat(specialProperties).concat(objectProperties);
  var subProperties = Object.keys(box).filter(function (key) {
    return propertyExclusions.indexOf(key) === -1;
  });

  var boxNode = document.createElement('mp4-box');
  var propertyNode = document.createElement('mp4-properties');
  var subBoxesNode = document.createElement('mp4-boxes');
  var boxTypeNode = document.createElement('mp4-box-type');

  if (box.type) {
    boxTypeNode.textContent = box.type;

    if (depth > 1) {
      boxTypeNode.classList.add('collapsed');
    }

    boxNode.appendChild(boxTypeNode);
  }

  attributes.forEach(function (key) {
    if (typeof box[key] !== 'undefined') {
      boxNode.setAttribute('data-' + key, box[key]);
    }
  });

  if (subProperties.length) {
    subProperties.forEach(function (key) {
      makeProperty(key, box[key], propertyNode);
    });
    boxNode.appendChild(propertyNode);
  }

  if (box.boxes && box.boxes.length) {
    box.boxes.forEach(function (subBox) {
      return domifyBox(subBox, subBoxesNode, depth + 1);
    });
    boxNode.appendChild(subBoxesNode);
  } else if (objectProperties.length) {
    objectProperties.forEach(function (key) {
      if (Array.isArray(box[key])) {
        domifyBox({
          type: key,
          boxes: box[key],
          size: box[key].size
        }, subBoxesNode, depth + 1);
      } else {
        domifyBox(box[key], subBoxesNode, depth + 1);
      }
    });
    boxNode.appendChild(subBoxesNode);
  }

  parentNode.appendChild(boxNode);
};

var makeProperty = function makeProperty(name, value, parentNode) {
  var nameNode = document.createElement('mp4-name');
  var valueNode = document.createElement('mp4-value');
  var propertyNode = document.createElement('mp4-property');

  nameNode.setAttribute('data-name', name);
  nameNode.textContent = name;

  if (value instanceof Uint8Array || value instanceof Uint32Array) {
    var strValue = (0, _commonDataToHexJs2['default'])(value, '');
    var sliceOffset = 0;
    var lines = 0;

    for (; sliceOffset < strValue.length; sliceOffset++) {
      if (strValue[sliceOffset] === '\n') {
        if (++lines === 21) {
          sliceOffset++;
          break;
        }
      }
    }
    var truncValue = strValue.slice(0, sliceOffset);

    if (truncValue.length < strValue.length) {
      truncValue += '<' + (value.byteLength - 336) + 'b remaining of ' + value.byteLength + 'b total>';
    }

    valueNode.setAttribute('data-value', truncValue.toUpperCase());
    valueNode.innerHTML = truncValue;
    valueNode.classList.add('pre-like');
  } else if (Array.isArray(value)) {
    var strValue = '[' + value.join(', ') + ']';
    valueNode.setAttribute('data-value', strValue);
    valueNode.textContent = strValue;
  } else {
    valueNode.setAttribute('data-value', value);
    valueNode.textContent = value;
  }

  propertyNode.appendChild(nameNode);
  propertyNode.appendChild(valueNode);

  parentNode.appendChild(propertyNode);
};

exports['default'] = {
  inspect: inspectTs,
  domify: domifyTs
};
module.exports = exports['default'];
},{"./common/aac-parse":14,"./common/data-to-hex.js":15,"./common/nal-parse":16}],21:[function(require,module,exports){
'use strict';
Object.defineProperty(exports, '__esModule', {
  value: true
});

var _expGolombString = require('./exp-golomb-string');

var _rbspUtils = require('./rbsp-utils');

var _mergeObj = require('./merge-obj');

/**
 * General ExpGolomb-Encoded-Structure Parse Functions
 */
var start = function start(name, parseFn) {
  return {
    decode: function decode(input, options, output) {
      var rawBitString = (0, _rbspUtils.typedArrayToBitString)(input);
      var bitString = rawBitString;

      options = options || {};
      output = output || {};

      if (!options.no_trailer_bits) {
        bitString = (0, _rbspUtils.removeRBSPTrailingBits)(rawBitString);
      }
      var expGolombDecoder = new _expGolombString.ExpGolombDecoder(bitString);

      try {
        return parseFn.decode(expGolombDecoder, output, options);
      } catch (e) {
        return e;
      }
    },
    encode: function encode(input, options) {
      var expGolombEncoder = new _expGolombString.ExpGolombEncoder();

      options = options || {};

      parseFn.encode(expGolombEncoder, input, options);

      var output = expGolombEncoder.bitReservoir;
      var bitString = (0, _rbspUtils.appendRBSPTrailingBits)(output);
      var data = (0, _rbspUtils.bitStringToTypedArray)(bitString);

      return data;
    }
  };
};

exports.start = start;
var startArray = function startArray(name, parseFn) {
  var startObj = start(name, parseFn);

  return {
    decode: function decode(input, options) {
      return startObj.decode(input, options, []);
    },
    encode: startObj.encode
  };
};

exports.startArray = startArray;
var list = function list(parseFns) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      parseFns.forEach(function (fn) {
        output = fn.decode(expGolomb, output, options, index) || output;
      });

      return output;
    },
    encode: function encode(expGolomb, input, options, index) {
      parseFns.forEach(function (fn) {
        fn.encode(expGolomb, input, options, index);
      });
    }
  };
};

exports.list = list;
var data = function data(name, dataType) {
  var nameSplit = name.split(/\[(\d*)\]/);
  var property = nameSplit[0];
  var indexOverride = undefined;
  var nameArray = undefined;

  // The `nameSplit` array can either be 1 or 3 long
  if (nameSplit && nameSplit[0] !== '') {
    if (nameSplit.length > 1) {
      nameArray = true;
      indexOverride = parseFloat(nameSplit[1]);

      if (isNaN(indexOverride)) {
        indexOverride = undefined;
      }
    }
  } else {
    throw new Error('ExpGolombError: Invalid name "' + name + '".');
  }

  return {
    name: name,
    decode: function decode(expGolomb, output, options, index) {
      var value = undefined;

      if (typeof indexOverride === 'number') {
        index = indexOverride;
      }

      value = dataType.read(expGolomb, output, options, index);

      if (!nameArray) {
        output[property] = value;
      } else {
        if (!Array.isArray(output[property])) {
          output[property] = [];
        }

        if (index !== undefined) {
          output[property][index] = value;
        } else {
          output[property].push(value);
        }
      }

      return output;
    },
    encode: function encode(expGolomb, input, options, index) {
      var value = undefined;

      if (typeof indexOverride === 'number') {
        index = indexOverride;
      }

      if (!nameArray) {
        value = input[property];
      } else if (Array.isArray(input[property])) {
        if (index !== undefined) {
          value = input[property][index];
        } else {
          value = input[property].shift();
        }
      }

      if (typeof value !== 'number') {
        return;
      }

      value = dataType.write(expGolomb, input, options, index, value);
    }
  };
};

exports.data = data;
var debug = function debug(prefix) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      console.log(prefix, expGolomb.bitReservoir, output, options, index);
    },
    encode: function encode(expGolomb, input, options, index) {
      console.log(prefix, expGolomb.bitReservoir, input, options, index);
    }
  };
};

exports.debug = debug;
var newObj = function newObj(name, parseFn) {
  var nameSplit = name.split(/\[(\d*)\]/);
  var property = nameSplit[0];
  var indexOverride = undefined;
  var nameArray = undefined;

  // The `nameSplit` array can either be 1 or 3 long
  if (nameSplit && nameSplit[0] !== '') {
    if (nameSplit.length > 1) {
      nameArray = true;
      indexOverride = parseFloat(nameSplit[1]);

      if (isNaN(indexOverride)) {
        indexOverride = undefined;
      }
    }
  } else {
    throw new Error('ExpGolombError: Invalid name "' + name + '".');
  }

  return {
    name: name,
    decode: function decode(expGolomb, output, options, index) {
      var value = undefined;

      if (typeof indexOverride === 'number') {
        index = indexOverride;
      }

      value = parseFn.decode(expGolomb, Object.create(output), options, index);

      if (!nameArray) {
        output[property] = value;
      } else {
        if (!Array.isArray(output[property])) {
          output[property] = [];
        }

        if (index !== undefined) {
          output[property][index] = value;
        } else {
          output[property].push(value);
        }
      }

      return output;
    },
    encode: function encode(expGolomb, input, options, index) {
      var value = undefined;

      if (typeof indexOverride === 'number') {
        index = indexOverride;
      }

      if (!nameArray) {
        value = input[property];
      } else if (Array.isArray(input[property])) {
        if (index !== undefined) {
          value = input[property][index];
        } else {
          value = input[property].shift();
        }
      }

      if (typeof value !== 'number') {
        return;
      }
      parseFn.encode(expGolomb, value, options, index);
    }
  };
};

exports.newObj = newObj;
var verify = function verify(name) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      var len = expGolomb.bitReservoir.length;
      if (len !== 0) {
        console.trace('ERROR: ' + name + ' was not completely parsed. There were (' + len + ') bits remaining!');
        console.log(expGolomb.originalBitReservoir);
      }
    },
    encode: function encode(expGolomb, input, options, index) {}
  };
};

exports.verify = verify;
var pickOptions = function pickOptions(property, value) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      if (typeof options[property] !== undefined) {
        //     options[property][value];
      }
    },
    encode: function encode(expGolomb, input, options, index) {
      if (typeof options[property] !== undefined) {
        //   options.values options[property][value];
      }
    }
  };
};
exports.pickOptions = pickOptions;
},{"./exp-golomb-string":25,"./merge-obj":26,"./rbsp-utils":27}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var when = function when(conditionFn, parseFn) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      if (conditionFn(output, options, index)) {
        return parseFn.decode(expGolomb, output, options, index);
      }

      return output;
    },
    encode: function encode(expGolomb, input, options, index) {
      if (conditionFn(input, options, index)) {
        parseFn.encode(expGolomb, input, options, index);
      }
    }
  };
};

exports.when = when;
var each = function each(conditionFn, parseFn) {
  return {
    decode: function decode(expGolomb, output, options) {
      var index = 0;

      while (conditionFn(index, output, options)) {
        parseFn.decode(expGolomb, output, options, index);
        index++;
      }

      return output;
    },
    encode: function encode(expGolomb, input, options) {
      var index = 0;

      while (conditionFn(index, input, options)) {
        parseFn.encode(expGolomb, input, options, index);
        index++;
      }
    }
  };
};

exports.each = each;
var inArray = function inArray(name, array) {
  var nameSplit = name.split(/\[(\d*)\]/);
  var property = nameSplit[0];
  var indexOverride = undefined;
  var nameArray = undefined;

  // The `nameSplit` array can either be 1 or 3 long
  if (nameSplit && nameSplit[0] !== '') {
    if (nameSplit.length > 1) {
      nameArray = true;
      indexOverride = parseFloat(nameSplit[1]);

      if (isNaN(indexOverride)) {
        indexOverride = undefined;
      }
    }
  } else {
    throw new Error('ExpGolombError: Invalid name "' + name + '".');
  }

  return function (obj, options, index) {
    if (nameArray) {
      return obj[property] && array.indexOf(obj[property][index]) !== -1 || options[property] && array.indexOf(options[property][index]) !== -1;
    } else {
      return array.indexOf(obj[property]) !== -1 || array.indexOf(options[property]) !== -1;
    }
  };
};

exports.inArray = inArray;
var equals = function equals(name, value) {
  var nameSplit = name.split(/\[(\d*)\]/);
  var property = nameSplit[0];
  var indexOverride = undefined;
  var nameArray = undefined;

  // The `nameSplit` array can either be 1 or 3 long
  if (nameSplit && nameSplit[0] !== '') {
    if (nameSplit.length > 1) {
      nameArray = true;
      indexOverride = parseFloat(nameSplit[1]);

      if (isNaN(indexOverride)) {
        indexOverride = undefined;
      }
    }
  } else {
    throw new Error('ExpGolombError: Invalid name "' + name + '".');
  }

  return function (obj, options, index) {
    if (nameArray) {
      return obj[property] && obj[property][index] === value || options[property] && options[property][index] === value;
    } else {
      return obj[property] === value || options[property] === value;
    }
  };
};

exports.equals = equals;
var gt = function gt(name, value) {
  var nameSplit = name.split(/\[(\d*)\]/);
  var property = nameSplit[0];
  var indexOverride = undefined;
  var nameArray = undefined;

  // The `nameSplit` array can either be 1 or 3 long
  if (nameSplit && nameSplit[0] !== '') {
    if (nameSplit.length > 1) {
      nameArray = true;
      indexOverride = parseFloat(nameSplit[1]);

      if (isNaN(indexOverride)) {
        indexOverride = undefined;
      }
    }
  } else {
    throw new Error('ExpGolombError: Invalid name "' + name + '".');
  }

  return function (obj, options, index) {
    if (nameArray) {
      return obj[property] && obj[property][index] > value || options[property] && options[property][index] > value;
    } else {
      return obj[property] > value || options[property] > value;
    }
  };
};

exports.gt = gt;
var not = function not(fn) {
  return function (obj, options, index) {
    return !fn(obj, options, index);
  };
};

exports.not = not;
var some = function some(conditionFns) {
  return function (obj, options, index) {
    return conditionFns.some(function (fn) {
      return fn(obj, options, index);
    });
  };
};

exports.some = some;
var every = function every(conditionFns) {
  return function (obj, options, index) {
    return conditionFns.every(function (fn) {
      return fn(obj, options, index);
    });
  };
};

exports.every = every;
var whenMoreData = function whenMoreData(parseFn) {
  return {
    decode: function decode(expGolomb, output, options, index) {
      if (expGolomb.bitReservoir.length) {
        return parseFn.decode(expGolomb, output, options, index);
      }
      return output;
    },
    encode: function encode(expGolomb, input, options, index) {
      parseFn.encode(expGolomb, input, options, index);
    }
  };
};

exports.whenMoreData = whenMoreData;
var whileMoreData = function whileMoreData(parseFn) {
  return {
    decode: function decode(expGolomb, output, options) {
      var index = 0;

      while (expGolomb.bitReservoir.length) {
        parseFn.decode(expGolomb, output, options, index);
        index++;
      }

      return output;
    },
    encode: function encode(expGolomb, input, options) {
      var index = 0;
      var length = 0;

      if (Array.isArray(input)) {
        length = input.length;
      }

      while (index < length) {
        parseFn.encode(expGolomb, input, options, index);
        index++;
      }
    }
  };
};
exports.whileMoreData = whileMoreData;
},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var getNumBits = function getNumBits(numBits, expGolomb, data, options, index) {
  if (typeof numBits === 'function') {
    return numBits(expGolomb, data, options, index);
  }
  return numBits;
};

var dataTypes = {
  u: function u(numBits) {
    return {
      read: function read(expGolomb, output, options, index) {
        var bitsToRead = getNumBits(numBits, expGolomb, output, options, index);

        return expGolomb.readBits(bitsToRead);
      },
      write: function write(expGolomb, input, options, index, value) {
        var bitsToWrite = getNumBits(numBits, expGolomb, input, options, index);

        expGolomb.writeBits(bitsToWrite, value);
      }
    };
  },
  f: function f(numBits) {
    return {
      read: function read(expGolomb, output, options, index) {
        var bitsToRead = getNumBits(numBits, expGolomb, output, options, index);

        return expGolomb.readBits(bitsToRead);
      },
      write: function write(expGolomb, input, options, index, value) {
        var bitsToWrite = getNumBits(numBits, expGolomb, input, options, index);

        expGolomb.writeBits(bitsToWrite, value);
      }
    };
  },
  ue: function ue() {
    return {
      read: function read(expGolomb, output, options, index) {
        return expGolomb.readUnsignedExpGolomb();
      },
      write: function write(expGolomb, input, options, index, value) {
        expGolomb.writeUnsignedExpGolomb(value);
      }
    };
  },
  se: function se() {
    return {
      read: function read(expGolomb, output, options, index) {
        return expGolomb.readExpGolomb();
      },
      write: function write(expGolomb, input, options, index, value) {
        expGolomb.writeExpGolomb(value);
      }
    };
  },
  b: function b() {
    return {
      read: function read(expGolomb, output, options, index) {
        return expGolomb.readUnsignedByte();
      },
      write: function write(expGolomb, input, options, index, value) {
        expGolomb.writeUnsignedByte(value);
      }
    };
  },
  val: function val(_val) {
    return {
      read: function read(expGolomb, output, options, index) {
        if (typeof _val === 'function') {
          return _val(expGolomb, output, options, index);
        }
        return _val;
      },
      write: function write(expGolomb, input, options, index, value) {
        if (typeof _val === 'function') {
          _val(ExpGolomb, output, options, index);
        }
      }
    };
  },
  byteAlign: function byteAlign() {
    return {
      read: function read(expGolomb, output, options, index) {
        return expGolomb.byteAlign();
      },
      write: function write(expGolomb, input, options, index, value) {}
    };
  }
};

exports['default'] = dataTypes;
module.exports = exports['default'];
},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {
  var length = data.length;
  var emulationPreventionBytesPositions = [];
  var i = 1;
  var newLength = undefined;
  var newData = undefined;

  // Find all `Emulation Prevention Bytes`
  while (i < length - 2) {
    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
      emulationPreventionBytesPositions.push(i + 2);
      i += 2;
    } else {
      i++;
    }
  }

  // If no Emulation Prevention Bytes were found just return the original
  // array
  if (emulationPreventionBytesPositions.length === 0) {
    return data;
  }

  // Create a new array to hold the NAL unit data
  newLength = length - emulationPreventionBytesPositions.length;
  newData = new Uint8Array(newLength);
  var sourceIndex = 0;

  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === emulationPreventionBytesPositions[0]) {
      // Skip this byte
      sourceIndex++;
      // Remove this position index
      emulationPreventionBytesPositions.shift();
    }
    newData[i] = data[sourceIndex];
  }

  return newData;
};

exports['default'] = discardEmulationPreventionBytes;
module.exports = exports['default'];
},{}],25:[function(require,module,exports){
/**
 * Tools for encoding and decoding ExpGolomb data from a bit-string
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var ExpGolombDecoder = function ExpGolombDecoder(bitString) {
  this.bitReservoir = bitString;
  this.originalBitReservoir = bitString;
};

exports.ExpGolombDecoder = ExpGolombDecoder;
ExpGolombDecoder.prototype.byteAlign = function () {
  var byteBoundary = Math.ceil((this.originalBitReservoir.length - this.bitReservoir.length) / 8) * 8;
  var bitsLeft = this.originalBitReservoir.length - byteBoundary;
  var bitsToRemove = this.bitReservoir.length - bitsLeft;

  return this.readRawBits(bitsToRemove);
};

ExpGolombDecoder.prototype.countLeadingZeros = function () {
  var i = 0;

  for (var _i = 0; _i < this.bitReservoir.length; _i++) {
    if (this.bitReservoir[_i] === '1') {
      return _i;
    }
  }

  return -1;
};

ExpGolombDecoder.prototype.readUnsignedExpGolomb = function () {
  var zeros = this.countLeadingZeros();
  var bitCount = zeros * 2 + 1;

  if (zeros === -1) {
    throw new Error('Error reading exp-golomb value.');
  }

  var val = parseInt(this.bitReservoir.slice(zeros, bitCount), 2);

  val -= 1;

  this.bitReservoir = this.bitReservoir.slice(bitCount);

  return val;
};

ExpGolombDecoder.prototype.readExpGolomb = function () {
  var val = this.readUnsignedExpGolomb();

  if (val !== 0) {
    if (val & 0x1) {
      val = (val + 1) / 2;
    } else {
      val = -(val / 2);
    }
  }

  return val;
};

ExpGolombDecoder.prototype.readBits = function (bitCount) {
  if (this.bitReservoir.length < bitCount) {
    throw new Error('Error reading bit stream value. There were (' + this.bitReservoir.length + ') bits remaining but expected (' + bitCount + ').');
  }

  var val = parseInt(this.bitReservoir.slice(0, bitCount), 2);

  this.bitReservoir = this.bitReservoir.slice(bitCount);

  return val;
};

ExpGolombDecoder.prototype.readRawBits = function (bitCount) {
  if (this.bitReservoir.length < bitCount) {
    throw new Error('Error reading bit stream value. There were (' + this.bitReservoir.length + ') bits remaining but expected (' + bitCount + ').');
  }

  var val = this.bitReservoir.slice(0, bitCount);

  this.bitReservoir = this.bitReservoir.slice(bitCount);

  return val;
};

ExpGolombDecoder.prototype.readUnsignedByte = function () {
  return this.readBits(8);
};

var ExpGolombEncoder = function ExpGolombEncoder(bitString) {
  this.bitReservoir = bitString || '';
};

exports.ExpGolombEncoder = ExpGolombEncoder;
ExpGolombEncoder.prototype.writeUnsignedExpGolomb = function (value) {
  var tempStr = '';
  var bitValue = (value + 1).toString(2);
  var numBits = bitValue.length - 1;

  for (var i = 0; i < numBits; i++) {
    tempStr += '0';
  }

  this.bitReservoir += tempStr + bitValue;
};

ExpGolombEncoder.prototype.writeExpGolomb = function (value) {
  if (value <= 0) {
    value = -value * 2;
  } else {
    value = value * 2 - 1;
  }

  this.writeUnsignedExpGolomb(value);
};

ExpGolombEncoder.prototype.writeBits = function (bitWidth, value) {
  var tempStr = '';
  var bitValue = (value & (1 << bitWidth) - 1).toString(2);
  var numBits = bitWidth - bitValue.length;

  for (var i = 0; i < numBits; i++) {
    tempStr += '0';
  }

  this.bitReservoir += tempStr + bitValue;
};

ExpGolombEncoder.prototype.writeRawBits = function (bitWidth, value) {
  var tempStr = '';
  var numBits = bitWidth - value.length;

  for (var i = 0; i < numBits; i++) {
    tempStr += '0';
  }

  this.bitReservoir += tempStr + value;
};

ExpGolombEncoder.prototype.writeUnsignedByte = function (value) {
  this.writeBits(8, value);
};
},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var mergeObj = function mergeObj(a, b) {
  var newObj = {};

  if (a) {
    Object.keys(a).forEach(function (key) {
      newObj[key] = a[key];
    });
  }

  if (b) {
    Object.keys(b).forEach(function (key) {
      newObj[key] = b[key];
    });
  }

  return newObj;
};
exports.mergeObj = mergeObj;
},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var typedArrayToBitString = function typedArrayToBitString(data) {
  var array = [];
  var bytesPerElement = data.BYTES_PER_ELEMENT || 1;
  var prefixZeros = '';

  for (var i = 0; i < data.length; i++) {
    array.push(data[i]);
  }

  for (var i = 0; i < bytesPerElement; i++) {
    prefixZeros += '00000000';
  }

  return array.map(function (n) {
    return (prefixZeros + n.toString(2)).slice(-bytesPerElement * 8);
  }).join('');
};

exports.typedArrayToBitString = typedArrayToBitString;
var bitStringToTypedArray = function bitStringToTypedArray(bitString) {
  var bitsNeeded = 8 - bitString.length % 8;

  // Pad with zeros to make length a multiple of 8
  for (var i = 0; bitsNeeded !== 8 && i < bitsNeeded; i++) {
    bitString += '0';
  }

  var outputArray = bitString.match(/(.{8})/g);
  var numberArray = outputArray.map(function (n) {
    return parseInt(n, 2);
  });

  return new Uint8Array(numberArray);
};

exports.bitStringToTypedArray = bitStringToTypedArray;
var removeRBSPTrailingBits = function removeRBSPTrailingBits(bits) {
  return bits.split(/10*$/)[0];
};

exports.removeRBSPTrailingBits = removeRBSPTrailingBits;
var appendRBSPTrailingBits = function appendRBSPTrailingBits(bits) {
  var bitString = bits + '10000000';
  var sliceAmount = bitString.length % 8;

  if (sliceAmount === 0) {
    return bitString;
  } else {
    return bitString.slice(0, -sliceAmount);
  }
};
exports.appendRBSPTrailingBits = appendRBSPTrailingBits;
},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _bitStreamsH264 = require('./bit-streams/h264');

var _bitStreamsH2642 = _interopRequireDefault(_bitStreamsH264);

var _inspectors = require('./inspectors');

var thumbCoil = {
  h264Codecs: _bitStreamsH2642['default'],
  mp4Inspector: _inspectors.mp4Inspector,
  tsInspector: _inspectors.tsInspector,
  flvInspector: _inspectors.flvInspector
};

// Include the version number.
thumbCoil.VERSION = '1.2.3';

exports['default'] = thumbCoil;
module.exports = exports['default'];
},{"./bit-streams/h264":6,"./inspectors":18}]},{},[28])(28)
});